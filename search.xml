<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[mklink]]></title>
    <url>%2F2019%2F05%2F09%2Fmklink%2F</url>
    <content type="text"><![CDATA[简介mklink 是 Windows 下用于创建符号链接的工具，存在于 Windows Vista 及以后版本的 Windows 操作系统中 目的资源存放在别的地方，通过mklink命令在原位置建立一个链接（假象）将资源映射过来，从而达到释放存储空间的作用。 语法MKLINK [[/D] | [/H] | [/J]] Link Target /D 创建目录符号链接。默认为文件符号链接。 /H 创建硬链接而非符号链接。 /J 创建目录联接。 Link 指定新的符号链接名称。 Target 指定新链接引用的路径(相对或绝对)。 实例新建一个test目录，里面创建两个子文件夹：resource 和 target ,在 resource 文件下创建一个test.txt文件。内容可以随意编辑，eg: Hello,I’m Silvia.123456mkdir testcd testmkdir resourcemkdir targetcd resourcetype nul&gt;test.txt 文件链接符号链接进入 target ，执行命令行1mklink test.txt ..\resource\test.txt mklink link_name target_name 特点： 在 target 文件夹下会有一个test.txt 移除源文件不会影响符号链接，打开会显示找不到文件 在系统中不占用空间 创建链接后的图标和快捷方式很像, 都有一个箭头的标志 链接文件任何内容的修改都会影响到源文件 链接文件的名字不会影响到源文件和符号链接 /J在 target 目录下，执行命令1mklink /j test ..\resource 如果 target 文件夹下面已经有了一个 test 文件夹，则会报当文件已存在时，无法创建该文件错误。 mklink /J link_name target_name 特点： 在 target 文件夹下会有一个 test 文件夹，文件夹下面是 resource 文件夹里面的所有文件 移除源文件不会影响符号链接，打开会显示找不到文件。 在系统中不占用空间 创建链接后的图标和快捷方式很像, 都有一个箭头的标志 link_name 文件夹里面的任何更改都会影响到源文件 link_name 文件夹重命名不会影响到源文件和符号链接 /H在 target 目录下，执行命令1mklink /H 1.txt ..\resource\test.txt /H 只能创建文件硬链接，而不能给文件夹创建硬链接。否则报拒绝访问错误 mklink /J link_name target_name 特点： 在 target 文件夹下会有一个 1.txt 在系统中占用的空间与源文件相同，但在系统中引用的是相同的对象（不是拷贝） 创建链接后的图标和快捷方式不同, 没有一个箭头的标志 link_name 文件夹里面的任何更改都会影响到源文件 link_name 文件夹重命名不会影响到源文件和符号链接 移除源文件不会影响硬链接 移除硬链接不会影响源文件 如果源文件被删除，它的内容依然通过硬链接存在。但是此时符号链接已失效。 硬链接只能用于文件，不能用于文件夹，而且硬链接和目标文件必须在同一个分区或者卷中。硬链接的目的是为了给文件创建多个目录路径，而不像符号链接是为了指向某个已有的文件 mklink /D和/J的区别目录符号链接和目录联接（看原文即目录的硬链接）的区别在于：目录联接在创建时会自动引用目标目录的绝对路径，而符号链接允许相对路径的引用。 eg:如分别用 mklink /D dira tdir 和 mklink /J dirb tdir 创建 dira、dirb 对相对目录的 tdir 的符号链接和目录联接，之后将 dira、dirb 移动到其它目录下，则访问 dira 时会提示“位置不可用”，访问 dirb 时仍然正常指向 tdir 本文参考链接：https://blog.csdn.net/guyue35/article/details/49761347]]></content>
      <categories>
        <category>Window下的命令</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>Window</tag>
        <tag>mklink</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MVVM模式--Vue 数据响应原理及代码实现]]></title>
    <url>%2F2019%2F04%2F12%2FMVVM%2F</url>
    <content type="text"><![CDATA[本文内容： Vue 数据双向绑定原理 代码实现 数据双向绑定MVVM 是Model-View-ViewModel 的缩写，它是一种基于前端开发的架构模式，其核心是提供对View 和 ViewModel 的双向数据绑定，这使得ViewModel 的状态改变可以自动传递给 View，即所谓的数据双向绑定 Vue 数据双向绑定原理Vue 虽然没有完全遵循 MVVM 模型，但是 Vue 的设计也受到了它的启发。如图所示，Vue 通过数据劫持结合发布者-订阅者模式的方式来实现的。new MVVM()即创建的一个Vue实例，实例下面有两个函数——监听器Observer和解析器Compile 监听器Observer负责劫持数据并监听数据变化，通知订阅者Watcher更新视图 解析器Compile负责解析指令、初始化视图、订阅数据变化并绑定更新函数 订阅者Watcher负责更新视图 消息订阅器Dep则是一个容器，收集订阅者Watcher 在创建Vue实例的时候，首先会去劫持数据，即监听器Observer截取Vue实例中的 data，并初始化一个消息订阅器Dep，订阅数据变化。接着解析器Compile开始递归循环解析指令，找到 v-text/v-model 并在Dep中添加订阅器，订阅数据变化，绑定更新函数。 说了这么多应该还是有点懵，那么接下来通过代码让我们更好地理解其中的原理 代码实现首先我们要明白MVVM模式，View(简称 V )和 Model(简称 M)是通过View-Model(简称 vm,即Vue实例)来连接的，V 发生变化，首先会通知 vm改变 M 中的数据，然后再更新视图。所以接下来我们可以将双向数据绑定开分成为两部分： 初始化视图，实现M–&gt;V 视图层发生变化， 数据更新到Model层， 再从Model层更新到View层，实现V–&gt;M 首先，创建一个index.html页面，其中引入Vue.js,并创建一个Vue实例1234567891011121314151617181920212223242526272829&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Vue 数据响应原理实现&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="el"&gt; &lt;h1&gt;Vue 数据响应原理实现&lt;/h1&gt; &lt;div&gt; &lt;div v-text="myText"&gt;&lt;/div&gt; &lt;div v-text="myBox"&gt;&lt;/div&gt; &lt;input type="text" v-model="myBox"&gt; &lt;/div&gt; &lt;/div&gt; &lt;script src="./vue.JS"&gt;&lt;/script&gt; &lt;script&gt; const vm=new Vue(&#123; el:"#el", data:&#123; myText:"起风了，要努力生存", myBox:"黯淡了刀光剑影，远去了鼓角争鸣" &#125; &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; el：为提供一个在页面上已存在的 DOM 元素作为 Vue 实例的挂载目标data: Vue 实例的数据对象 M–&gt;V首先，需要创建一个类Vue和一个类Watcher，其中Vue的constructor接收Vue实例传过来的数据，完成初始化绑定以及初始化一个订阅者容器。接着劫持数据，然后再进行解析指令等动作。12345678910111213141516171819202122232425262728293031class Vue&#123; constructor(option)&#123; this.option = option; this.$data = option.data; this.el = document.querySelector(option.el); // 初始化一个订阅者容器 this._director = &#123;&#125; this.Observer(this.$data); this.Compile(this.el); &#125; // 劫持数据 Observer(data)&#123; &#125; // 解析指令、初始化视图、订阅数据变化并绑定更新函数 Compile(el)&#123; &#125;&#125;// 订阅者class Watch()&#123; constructor()&#123; // 初始化视图 this.update(); &#125; update()&#123; &#125;&#125; Vue 是局部刷新数据，因此某数据发生改变时，只会通知相关的订阅者更新视图。因此消息订阅器的格式应为：{myText:[订阅者1,订阅者2],myBox:[订阅者1,订阅者2]}123456// 实现数据劫持、通知数据变化Observer(data)&#123; for (let key in data) &#123; this._director[key] = []; &#125;&#125; 通过循环递归this.el下的子元素，找到具有 v-text/v-model的元素，并给它们添加订阅者12345678910111213141516171819// 解析指令、初始化视图、订阅数据变化并绑定更新函数Compile(el)&#123; let nodes = el.children; for(let i = 0;i&lt;nodes.length;i++)&#123; let node = nodes[i]; // 递归循环 if(node.children.length)&#123; this.Compile(node); &#125; // 解析v-text指令 if(node.hasAttribute(&apos;v-text&apos;))&#123; &#125; // 解析v-model指令 if (node.hasAttribute(&apos;v-model&apos;)) &#123; &#125; &#125;&#125; 那么添加订阅器？且看代码123456789101112// 解析v-text指令if(node.hasAttribute('v-text'))&#123; let attrT = node.getAttribute('v-text'); // 添加订阅者 this._director[attrT].push(new Watcher(node,this,attrT,'innerHTML'));&#125;// 解析v-model指令if (node.hasAttribute('v-model')) &#123; let attrM = node.getAttribute('v-model'); // 添加订阅者 this._director[attrM].push(new Watcher(node, this, attrM, 'value'));&#125; 获取 v-text/v-model 属性值，通过创建Watcher实例订阅数据变化。那么为什么给Watcher传递这四个参数？1234567891011121314// 订阅者class Watcher&#123; constructor(el,vm,exp,attr)&#123; this.el = el; this.vm = vm; this.exp = exp; this.attr = attr; // 初始化视图 this.update(); &#125; update()&#123; this.el[this.attr] = this.vm.$data[this.exp] &#125;&#125; 我们要去改变元素的节点内容，可以通过 el.innerHTML = Vue实例.$data[attr] 或者 el.value = Vue实例.$data[attr] 。但是Class 中并不能获取到这些数据。因此，我们需要将当前要更新的节点、Vue实例、要更改的 data 和 innerHTML/value 传递给 Watcher 。 到这里我们就已经实现了从 M 到 V V–&gt;M要实现V–&gt;M,首先需要在解析器中绑定数据监听 更新到M123456789101112131415161718192021222324252627282930// 解析指令、初始化视图、订阅数据变化并绑定更新函数Compile(el)&#123; console.log(22222) let nodes = el.children; for(let i = 0;i&lt;nodes.length;i++)&#123; let node = nodes[i]; // 递归循环 if(node.children.length)&#123; this.Compile(node); &#125; // 解析v-text指令 if(node.hasAttribute('v-text'))&#123; let attrT = node.getAttribute('v-text'); // 添加订阅者 this._director[attrT].push(new Watcher(node,this,attrT,'innerHTML')); &#125; // 解析v-model指令 if (node.hasAttribute('v-model')) &#123; let attrM = node.getAttribute('v-model'); // 添加订阅者 this._director[attrM].push(new Watcher(node, this, attrM, 'value')); // 绑定数据监听 更新到M node.addEventListener('input', (function (event) &#123; return function (event) &#123; this.$data[attrM] = event.target.value; &#125; &#125;)().bind(this)); &#125; &#125;&#125; 解释：监听事件中的 this 指向的并不是Vue实例，而是当前node，因此我们需要给其绑定this。至于返回一个匿名函数，是因为我们需要事件是在输入文本框的时候执行，而不是绑定的时候就执行。 到目前为止，我们还未涉及到数据双向绑定的原理：Object.definedPrototype()。Observer中除了实现数据劫持还需要通知数据变化1234567891011121314151617181920212223242526// 实现数据劫持、通知数据变化Observer(data)&#123; console.log(11111) // 数据劫持 // Vue更新数据的时候是局部刷新，当改变myBx时只会刷新myBox的数据，所以this._director的格式应该是&#123;myText:[订阅者1，订阅者2],myBox:[订阅者1，订阅者2]&#125; for (let key in data) &#123; this._director[key] = []; let val = this.$data[key]; // 不能使用var 否则会出现Object.defineProperty中的val为最后一次获取到的this.$data[key] // 获取订阅者实例 let watch = this._director[key]; // 数据变化通知订阅者 更新视图 Object.defineProperty(this.$data,key,&#123; get:function () &#123; return val &#125;, set:function (newVal) &#123; if (newVal !== val)&#123; val = newVal; watch.forEach(element =&gt; &#123; element.update(); &#125;); &#125; &#125; &#125;); &#125;&#125; 这里就很简单了，通过Object.defineProperty的 get/set 当数据变化的时候触发订阅器的 update() 实现更新 结束总结：Object.defineProperty 只有在视图层数据发生改变时才会触发 set 事件。并且是先将this.$data中的数据更新，然后在 set 更新视图层 vue.js完整代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788class Vue&#123; /* * MVVM模式， Object.defineProperty 这个API只有在从视图层数据发生改变时，数据更新到Model层，再从Model层更新到View层时起作用 * 1. 初始化视图，实现M--&gt;V * 2. 视图层发生变化， 数据更新到Model层， 再从Model层更新到View层 */ // 接收参数 constructor(option)&#123; this.option = option; this.$data = option.data; this.el = document.querySelector(option.el); // 初始化一个订阅者容器 this._director = &#123;&#125; this.Observer(this.$data); this.Compile(this.el); &#125; // 实现数据劫持、通知数据变化 Observer(data)&#123; // 数据劫持 // Vue更新数据的时候是局部刷新，当改变myBx时只会刷新myBox的数据，所以this._director的格式应该是&#123;myText:[订阅者1，订阅者2],myBox:[订阅者1，订阅者2]&#125; for (let key in data) &#123; this._director[key] = []; let val = this.$data[key]; // 不能使用var 否则会出现Object.defineProperty中的val为最后一次获取到的this.$data[key] // 获取订阅者实例 let watch = this._director[key]; // 数据变化通知订阅者 更新视图 Object.defineProperty(this.$data,key,&#123; get:function () &#123; return val &#125;, set:function (newVal) &#123; if (newVal !== val)&#123; val = newVal; watch.forEach(element =&gt; &#123; element.update(); &#125;); &#125; &#125; &#125;); &#125; &#125; // 解析指令、初始化视图、订阅数据变化并绑定更新函数 Compile(el)&#123; let nodes = el.children; for(let i = 0;i&lt;nodes.length;i++)&#123; let node = nodes[i]; // 递归循环 if(node.children.length)&#123; this.Compile(node); &#125; // 解析v-text指令 if(node.hasAttribute('v-text'))&#123; let attrT = node.getAttribute('v-text'); // 添加订阅者 this._director[attrT].push(new Watcher(node,this,attrT,'innerHTML')); &#125; // 解析v-model指令 if (node.hasAttribute('v-model')) &#123; let attrM = node.getAttribute('v-model'); // 添加订阅者 this._director[attrM].push(new Watcher(node, this, attrM, 'value')); // 绑定数据监听 更新到M node.addEventListener('input', (function (event) &#123; return function (event) &#123; this.$data[attrM] = event.target.value; &#125; &#125;)().bind(this)); &#125; &#125; &#125;&#125;// 订阅者class Watcher&#123; constructor(el,vm,exp,attr)&#123; this.el = el; this.vm = vm; this.exp = exp; this.attr = attr; // 初始化视图 this.update(); &#125; update()&#123; this.el[this.attr] = this.vm.$data[this.exp] &#125;&#125;]]></content>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RegExp 正则]]></title>
    <url>%2F2019%2F04%2F08%2FRegExp%2F</url>
    <content type="text"><![CDATA[RegExp类型正则表达式：pattern部分是简单或复杂的正则表达式，一个正则可以带一个或多个flags标志(匹配模式)1var expression = /pattern / flags; 匹配模式有： g：全局，应用于全部字符串，会影响reg.lastIndex值 i：不区分大小 m：多行模式 元字符元字符是指在正则表达式中含有一种或多种特殊用途的符号，元字符有：1() [] &#123;&#125; \ ^ $ | ? * + . 元字符 \ 转义字符（把一个普通字符转变为有特殊意义的字符，或者把一个有意义的字符转变为普通字符） 12345678910111213141516var t1 = '0';var t2 = '\\d';var t3 = '\\0';var t4 = '\\\\d';var reg1 = /^\d$/ // 匹配一个0-9的数字var reg2 = /^\\d$/ // 匹配 '\\d' 字符串var reg3 = /^\\\d$/ // 匹配 '\\[0-9]' 字符串var reg4 = /^\\\\d$/ // 匹配 '\\\\d' 字符串console.log(t1)console.log(t2)console.log(t3)console.log(t4)console.log(reg1.test(t1));console.log(reg2.test(t2));console.log(reg3.test(t3));console.log(reg4.test(t4)); 结果如下： 123456780\d\0\\dtruetruetruetrue 解释：JS中的字符串 \ 同样也具有转义功能，如 t2,第一个 \ 将第二个 \ 转移成普通字符串，因此console.log(t2)为 \d。正则匹配中匹配 t2 也一样，/^\\d$/ 第一个 \ 将第二个 \ 转义成普通字符串，因此就可以匹配 \d，而 \d 的字符串表达为 \\d t2: 控制台——\d字符串表示——\\d正则表示——/^\\d$/ . 除了\n（换行符）以外的任意字符 \d 匹配一个0~9之间的数字 \D 匹配一个非0~9之间的数字（大写与小写字母组合正好是相反含义 \w 匹配一个0~9或字母或_之间的一个字符 \s 匹配一个任意空白字符，等价于 \f\n\r\t\v \b 匹配一个边界符 x|y 匹配x或者y中的一个 [a-z] 匹配a-z中的任意一个字符 [^a-z] 匹配非a-z中的任意一个字符 [xyz] 匹配x或y或z中的一个字符 [^xyz] 和上方相反 () 整的小分组，匹配一个小分组（可以理解为大正则中的一个小正则，整个正则为最大的大正则） ^ 以某一个元字符开始 $ 以某一个元字符结束 ?: 只匹配不捕获 ?= 正向肯定预查 ?! 正向否定预查 量词：用来描述元字符出现的次数 + 让前面的元字符出现一到多次 ? 出现零到一次 * 出现零到多次 {n} 出现n次 {n,} 出现n到多次 {n,m} 出现n到m次 想匹配字符串中包含的这些元字符时要对其进行转义 创建正则的2种方式字面量和new RegExp()构造函数。其中构造函数接收2个参数：匹配的字符串模式和标志字符串。规则：所有的元字符都必须双重转义，\ 字符在字符串中通常被转义为 \\ 。技巧：可先将匹配模式转换为字面量模式，在转换为等价的字符串模式123// 要匹配字符串 \\dvar reg1 = /^\\\\d$/var reg2 = new RegExp(`^\\\\\\\\d$`); 正则实例方法 exec()：捕获组。接收一个参数，即要匹配的字符串，返回值是一个匹配信息的数组,其中包含groups/index/input/length等属性，如果没有匹配成功则返回null。 123456789101112var text = 'mom and dad and baby';var reg10 = /mom( and dad( and baby)?)?/gi;console.log(reg10.exec(text));var reg11 = /([a-z]+)/gvar str11 = 'my name is &#123;weiran&#125;. I am from &#123;china&#125;'var result = []while (reg11.test(str11)) &#123; result.push(RegExp.$1)&#125;console.log(result); 在RegExp的constructor中存在$1-$9，他们的具体指的是当前本次匹配小分组第一到第九捕获的内容 match()：匹配，当加了修饰符g，返回的是大正则匹配结果组成的数组，不加修饰符g则返回大正则和每个小分组返回结果组成的数组，匹配不到返回null。语法：str.match(reg) test()：匹配，返回true/false。语法：reg.test(str) serch()：查找，返回匹配元素的起始位置，如果没有返回-1，不支持修饰符g replace()：替换，不改变原字符串。str.replace(regexp|substr, newSubStr|function)function (replacement)：一个用来创建新子字符串的函数，该函数的返回值将替换掉第一个参数匹配到的结果。参考下面的指定一个函数作为参数 split：按照正则方式可以拆分成数组。str.split(reg)，不改变原字符串 元字符表 练习原文地址 字符转成驼峰式，如：’get-element-by-id’; 我的思路： 12345678910111213function transfer(str) &#123; var reg = /([\w]+)/g; var reg2 = /^[a-z]/; var result=[],arr=[]; while (reg.test(str)) &#123; var curr = RegExp.$1; if(arr.length)&#123; curr = curr.replace(reg2, curr.slice(0, 1).toUpperCase()); &#125; arr.push(curr) &#125; return arr.join('')&#125; 原文思路： 123456var f = function (s) &#123; return s.replace(/-\w/g, function (x) &#123; console.log(x); // 这里的x为每次匹配到的值：-e -b -i return x.slice(1).toUpperCase(); &#125;)&#125; 判断字符串是否包含数字 我的思路： 123var isN = function(str) &#123; return str.search(/\d/) &gt;=0 ? true:false&#125; 原文思路 1234function containsNumber(str) &#123; var regx = /\d/; return regx.text(str);&#125; 判断电话号码 规则：以数字1开头，第二位为3、4、5、7、8中的任意一位，剩下的9位为0-9之间的数字。共11位 1234var isTel = function (str) &#123; var reg = /^1[34578]\d&#123;9&#125;$/; return reg.test(str);&#125; 给定字符串str，检查其是否符合如下格式：XXX-XXX-XXXX，其中X为Number类型 我的思路： 1234var isT = function (str) &#123; var reg = /^\d&#123;3&#125;-\d&#123;3&#125;-\d&#123;4&#125;$/; return reg.test(str);&#125; 原文思路： 123function matchesPattern(str) &#123; return /^(\d&#123;3&#125;-)&#123;2&#125;\d&#123;4&#125;$/.test(str);&#125; 判断是否符合USD格式 以 $ 开始 整数部分，从个位起，满 3 个数字用 , 分隔 如果为小数，则小数部分长度为 2 可以没有小数 正确的格式如：$1,023,032.03 或者 $2.03，错误的格式如：$3,432,12.12 或者 $34,344.3** 1234var isDollor = function (str) &#123; var reg = /^\$(\d)&#123;1,3&#125;(,\d&#123;3&#125;)*(\.[\d]&#123;1,2&#125;)?$/ return reg.test(str)&#125; 实现trim() MDN兼容模式： 12345if (!String.prototype.trim) &#123; String.prototype.trim = function () &#123; return this.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, ''); &#125;;&#125; \s：空格 \uFEFF：字节次序标记字符（Byte Order Mark），也就是BOM,它是es5新增的空白符 \xA0：禁止自动换行空白符，相当于html中的&nbsp; 参考文献：https://juejin.im/post/5b62717ee51d4519873f858a]]></content>
      <categories>
        <category>红皮书笔记--《JavaScript高级程序设计》</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webpack 4 从零开始]]></title>
    <url>%2F2019%2F04%2F08%2Fwebpack-test%2F</url>
    <content type="text"><![CDATA[小白入门级别的webpack实践，只学会用，不用在意为什么 项目地址：git@github.com:Oldpost/webpack-test.git 安装全局1npm install webpack –g 本地1npm install webpack –save-dev 测试1webpack -v 准备工作新建一个空项目并初始化,创建一个dist/index.html和index.js123mkdir webpack-testcd webpack-testnpm init index.html123456789101112&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;webpack test&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script src="bundle.js"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; index.js1document.write('今天天气很好') 开始第一个webpack命令行执行1webpack index.js bundle.js 报错原因：版本太高，命令过时了。改成1webpack index.js -o bundle.js Hash:hash值 Version:webpack版本 time:这次打包所花费的时间 Asset:打包这次生成的文件 Size:这次生成文件的大小 Chunks:这次打包的分块 chunk Names:这次打包的名称 此时警告：123WARNING in configurationThe 'mode' option has not been set, webpack will fallback to 'production' for this value. Set 'mode' option to 'development' or 'production' to enable defaults for each environment.You can also set it to 'none' to disable any default behavior. Learn more: https://webpack.js.org/concepts/mode/ 是因为webpack4引入了模式,有开发模式,生产模式,无这三个状态。暂时可忽略。 此时打包完成，打开dist文件夹下，可以看到打包好的bundle.js文件 通过配置文件打包以及开发新建webpack.config.js文件，并在package.json文件里配置scripts字段1"build": "webpack --mode production" webpack.config.js需要配置其文件的入口及出口1234567891011121314151617const path = require('path');module.exports = &#123; entry:"./src/index.js", output:&#123; path: path.resolve(__dirname, 'dist'), filename: 'bundle.js' &#125;, module:&#123; rules:[ &#123; test: /\.css$/, use: ['style-loader','css-loader'] &#125; ] &#125;, plugins:[]&#125; path 是一个 Node.js 核心模块，用于操作文件路径。entry:入口的文件，即要处理的文件(现在只做单个入口)、output：出口的文件，可配置出口文件路径以及文件相关信息、module：即配置 loader,可以通过配置 loader 扩展其他语言，如scss、plugins：插件 命令行运行：1npm run build 此时打包完成，打开dist文件夹下，可以看到打包好的bundle.js文件 开发过程在开发过程中为了避免改一点代码就运行一次命令，加入开发模式。首先需要安装webpack-dev-server1npm install --save-dev webpack-dev-server 在package.json文件里配置scripts字段1"start": "webpack-dev-server --mode development --open", –open：自动打开窗口123456789// webpack.config.js需要配置 devServermodule.exports = &#123; ... devServer: &#123; contentBase: path.join(__dirname, "dist"), hot: true, // 开启实时刷新 port: 9000 // 端口，默认8080 &#125;&#125; 错误追踪为了更容易地追踪错误和警告，JavaScript 提供了 source map 功能，将编译后的代码映射回原始源代码。如果一个错误来自于 b.js，source map 就会明确的告诉你。在package.json文件里配置，1devtool: 'inline-source-map', 更多 动态页面通常我们需要开发一个动态的html文件，而不是直接在dist文件夹里面放进去一个静态文件。这里使用到 html-webpack-plugin 插件1npm install --save-dev html-webpack-plugin webpack.config.js123456789const HtmlWebpackPlugin = require('html-webpack-plugin'); // 动态生成html文件module.exports = &#123; ... plugins: [ new HtmlWebpackPlugin(&#123; template: path.resolve(__dirname, 'src/index.html'), &#125;) ],&#125; 编译文件前清空dist1npm install --save-dev clean-webpack-plugin webpack.config.js1234567const CleanWebpackPlugin = require('clean-webpack-plugin'); // 动态生成html文件module.exports = &#123; ... plugins: [ new CleanWebpackPlugin(), ],&#125; 哈希值可以在 output 里配置输出文件的文件名。当文件变化的时候加载新文件 否则使用缓存1234567module.exports = &#123; ... output:&#123; path: path.resolve(__dirname, 'dist'), filename: 'bundle.[chunkhash].js' &#125;,&#125; hash：hash值是特定于整个构建过程的 chunkhash：hash值是特定于每一个文件的内容的 图片file-loader1npm install url-loader file-loader html-withimg-loader --save-dev url-loader： 功能类似于 file-loader，但是在文件大小(单位 byte)低于指定的限制(limit)时，可以返回一个 DataURL file-loader：直接将图片打包到生产目录下 html-withimg-loader：处理html中直接使用src引用的img使用相对路径12// index.html&lt;img src="images/750x380.cc8da272.png" alt="" sizes="" srcset=""&gt; webpack.config.js配置123456789101112131415161718192021222324252627282930module.exports = &#123; ... module:&#123; rules:[ ... &#123; test: /\.(png|jpg)$/, use: [&#123; loader: 'url-loader', // 将小于8K的图片以base64的形式打包到js文件中 options: &#123; limit: 8192, // 文件大小 name: '[name].[hash:8].[ext]', // 设置文件名 // name(file) &#123; // if (process.env.NODE_ENV === 'development') &#123; // return '[path][name].[ext]'; // &#125; // return '[hash].[ext]'; // &#125;, outputPath: 'images', // 新增一层文件路径 &#125; &#125;], &#125;, &#123; test: /\.html$/, loader: 'html-withimg-loader' &#125; ] &#125;&#125; name：当配置为 [path][name].[ext] 时，会将路径也一并打包，ext：目标文件/资源的文件扩展名。path：相对于webpack/config 文件的路径outputPath: 指定文件路径 css 分离打包webpack4之前使用 extract-text-webpack-plugin，现在用 mini-css-extract-plugin 代替1npm install --save-dev mini-css-extract-plugin webpack.config.js配置1234567891011121314151617181920212223242526272829303132const MiniCssExtractPlugin = require("mini-css-extract-plugin"); // webpack分离css单独打包module.exports = &#123; ... module:&#123; modules:[ &#123; test: /\.css$/, use: [ &#123; loader: MiniCssExtractPlugin.loader, options: &#123; // you can specify a publicPath here // by default it use publicPath in webpackOptions.output &#125; &#125;, // 在这里带调用 style-loader 会报错 "css-loader" ] // use: ['style-loader', 'css-loader'] // 先调用css-loader，解决不了在调用style-loader &#125;, ... ] plugins:[ new MiniCssExtractPlugin(&#123; // Options similar to the same options in webpackOptions.output // both options are optional filename: "[name].css", chunkFilename: "[id].css" &#125;), ] &#125;&#125;]]></content>
      <categories>
        <category>webpack学习</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[interview]]></title>
    <url>%2F2019%2F03%2F29%2Finterview%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[操作符]]></title>
    <url>%2F2019%2F03%2F22%2Foperate%2F</url>
    <content type="text"><![CDATA[一元操作符只能操作一个值的操作符叫做一元操作符 ++ --++和--都有前置递增/递减 和 后置递增/递减区别(eg:i++、++i)：i++ 会先操作再自加1，++i会先自加1再操作。12345678910var a =10,b = 20,num1 = 10,num2 = 20,c,num3c = ++a + b; //31// 相当于a = a+1;c = a+b;num3 = num1++ + num2; // 30// 相当于num3 = num1 + num2;num1 = num1 + 1; 操作对象： 整数 字符串: 如果是一个包含有效数字的字符串，那先将字符串转化为数字值再执行加减1操作，如果是不包含有效数字的字符串，则将字符串转换为NaN。字符串最后都会变成数值变量 12345var text1 = '10', text2 = 'Silvia 10'console.log(text1++ + 2); // 12 相当于先转换为10 执行10+2，在自加1console.log(++text1 + 2); // 14 此时text1为数值11，先自加1，在执行12+2console.log(text2++ + 2); // NaNconsole.log(++text2 + 2); // NaN 布尔值：如果是 false 则先转换为0在执行加减1，如果是 true 则先转换为1在执行加减1。最后都会变成数值变量 浮点数值 对象：先调用对象的valueOf()以取得一个可供操作的值，然后对该值应用上述规则，如果结果是NaN，在调用toString()方法后在进行上述规则。最后都会变成数值变量 + -对于非数值变量，会像Number()转型函数一样对该值执行转换 位操作符位操作符作用于最基本的层次上，即按照内存中表示数值的位来操作数值。ECMAScript中所有的数值都以 IEEE-754 64位格式存储。但是位操作符不是直接操作64位，而是先将64位的值转换为32位在进行操作。 有符号位的整数，32位中的前31位用于表示整数的值，第32位表示数值的符号。正数以纯二进制存储，31位中的每一位都表示2的幂。eg:18的二进制有效位为5位 10010。负数同样以二进制码存储，使用的是二进制补码,其补码过程： 求这个值绝对值的二进制 求二进制反码 得到的反码加1 二进制与十进制转换(整数) 正整数转成二进制：除二取余，然后倒序排列，高位补零。或者循环取最接近该数值的2的n次方，直到加起来等于该值 142: 2^5 + 2^3 + 2 = 0010 1010 负整数转换成二进制：先是将对应的正整数转换成二进制后，对二进制取反(反码)，然后对结果再加一(补码) 1-42: 0010 1010(42源码) --&gt; 1101 0101(反码) --&gt; 1101 0110(补码) 正数二进制转十进制：将二进制中的位数分别将下边对应的值相乘，然后相加得到的就为十进制 10010 1010 --&gt; 2^5 + 2^3 + 2 = 42 // 首位不进入计算，符号位 负数二进制转十进制：先减1(反码)，再取反(源码),在换算成十进制 12// 首位不进入计算，符号位-42: 1101 0110 --&gt; 1101 0101(反码) --&gt; 1010 1010(源码) --&gt; -(2^5 + 2^3 + 2) = -42 按位非 ~返回数值的反码–本质上就是操作数的负数减112345678var num = 25;var num2 = ~num;console.log(num2); // -26// num = 0000 0000 0000 0000 0000 0000 0001 1001 = 25// num2 = 1111 1111 1111 1111 1111 1111 1110 0110// 反码 = 1111 1111 1111 1111 1111 1111 1110 0101// 源码 = 1000 0000 0000 0000 0000 0000 0001 1010 = -26 按位与 &amp;两个数值先转换为二进制码，再按位进行判断–对应位都为1才为1，否则为0。eg:123456var result = 25 &amp; -3;// 25 = 0000 0000 0000 0000 0000 0000 0001 1001 // 3 = 1111 1111 1111 1111 1111 1111 1111 1101// -------------------------------------------// AND= 0000 0000 0000 0000 0000 0000 0001 1001console.log(result); // 2^4+2^3+1 = 25 按位或 |两个数值先转换为二进制码，再按位进行判断–对应位只要有一个为1就为1，否则为0。eg:123456var result = 25 | 3;// 25 = 0000 0000 0000 0000 0000 0000 0001 1001// 3 = 0000 0000 0000 0000 0000 0000 0000 0011// -------------------------------------------// AND= 0000 0000 0000 0000 0000 0000 0001 1011console.log(result); // 2^4+2^3+2^1+1 = 27 按位异或 ^两个数值先转换为二进制码，再按位进行判断–对应位相同则为0，不同则为1。eg:123456var result = 25 ^ 3;// 25 = 0000 0000 0000 0000 0000 0000 0001 1001// 3 = 0000 0000 0000 0000 0000 0000 0000 0011// -------------------------------------------// AND= 0000 0000 0000 0000 0000 0000 0001 1010console.log(result); // 2^4+2^3+2^1 = 26 应用：交换2个数值，不适用中间量1234var a=2,b=3;a =a ^ b;b =a ^ b;a =a ^ b; 左移 &lt;&lt;将数值的所有位向左移动指定的位数,多出的0补充。左移n位后的值 等于原值乘以2的n次方eg:123456789var oldValue = -2;var newValue = oldValue &lt;&lt; 5; // 64// 源码 = 1000 0000 0000 0000 0000 0000 0000 0010 // 反码 = 1111 1111 1111 1111 1111 1111 1111 1101// 补码 = 1111 1111 1111 1111 1111 1111 1111 1110// 左移 = 1111 1111 1111 1111 1111 1111 1100 0000// 反码 = 1111 1111 1111 1111 1111 1111 1011 1111// 源码 = 1000 0000 0000 0000 0000 0000 0100 0000 有符号位的右移 &gt;&gt;将数值的所有位向左移动指定的位数,多出的0补充,不影响符号位。右移n位后的值 等于原值除以2的n次方的商eg:12345678910111213141516171819var oldValue = -64;var newValue = oldValue &gt;&gt; 5; // -2// 源码 = 1000 0000 0000 0000 0000 0000 0100 0000// 反码 = 1111 1111 1111 1111 1111 1111 1011 1111// 补码 = 1111 1111 1111 1111 1111 1111 1100 0000// 右移 = 1111 1111 1111 1111 1111 1111 1111 1110// 反码 = 1111 1111 1111 1111 1111 1111 1111 1101// 源码 = 1000 0000 0000 0000 0000 0000 0000 0010// 整数 = -2var oldValue2 = -65;var newValue2 = oldValue &gt;&gt; 5; // -3// 源码 = 1000 0000 0000 0000 0000 0000 0100 0001// 反码 = 1111 1111 1111 1111 1111 1111 1011 1110// 补码 = 1111 1111 1111 1111 1111 1111 1011 1111// 右移 = 1111 1111 1111 1111 1111 1111 1111 1101// 反码 = 1111 1111 1111 1111 1111 1111 1111 1100// 源码 = 1000 0000 0000 0000 0000 0000 0000 0011// 整数 = -3 无符号右移 &gt;&gt;&gt;无符号位对正整数没影响，但是对于负整数来说填充位为0，并且无符号位会把负数的二进制当成正数的二进制码。1234567var oldValue2 = -64;var newValue2 = oldValue &gt;&gt;&gt; 5; // 134217726// 源码 = 1000 0000 0000 0000 0000 0000 0100 0001// 反码 = 1111 1111 1111 1111 1111 1111 1011 1110// 补码 = 1111 1111 1111 1111 1111 1111 1011 1111// 右移 = 0000 0111 1111 1111 1111 1111 1111 1101// 整数 = 134217726 布尔值操作符逻辑非 !应用于任何值，最终返回布尔值。规则会先将操作数转换成布尔值，再求其反： 操作数为对象,返回false 操作数为空字符串，返回true 操作数为非空字符串，返回false 1console.log(!'0') // false 操作数为数值0，返回true 操作数为任意非数值0(包括Infinity)，返回false 1console.log(!Infinity) // false 操作数为null，返回true 操作数为undefined，返回true 操作数为NaN，返回true 应用：同时用两个逻辑非将一个值转换为与其对应的布尔值。实际上就是模拟Boolean()转型函数1console.log(!!'0') // true 逻辑与 &amp;&amp;全部为true才为true。可用于任何类型的操作数。在有一个操作数不是布尔值的情况下，返回值的规则为： 如果第一个操作数是对象，则返回第二个操作数 1console.log(Boolean(obj1)) // true 如果第二个操作数，则只有在第一个操作数的求值结果为true的情况下才会返回该对象 如果第一个操作数树null，则返回null 如果第一个操作数树NaN，则返回NaN 如果第一个操作数树undefined，则返回undefined 总结：第一个操作数的布尔值为false就返回第一个操作数,eg: null、undefined、NaN、fasle、0。 逻辑或 ||只要有一个为true就为true 如果第一个操作数是对象，则返回第一个操作数 如果第一个操作数的求值结果为false，则返回第二个操作数 如果两个操作数是对象，则返回第一个操作数 如果两个操作数树null，则返回null 如果两个操作数树NaN，则返回NaN 如果两个操作数树undefined，则返回undefined 乘性操作数3个乘性操作符：乘法、除法和求模。在操作非数值型的数值时自动进行类型转换–后台调用Number()转型函数将其转换为数值 乘法 *特殊情况规则： 两个数值相乘的结果超过ECMAScript数值的范围，则返回Infinity或者-Infinity 有一个操作数为NaN,则结果是NaN Infinity * 0，结果为NaN Infinity * 非0数值，结果为Infinity或者-Infinity Infinity * -Infinity，结果为-Infinity 1-Infinity * -Infinity == Infinity 乘数为非数值时先调用Number()转型函数将其转换为数值 除法 /特殊情况： 两个数值相乘的结果超过ECMAScript数值的范围，则返回Infinity或者-Infinity 有一个操作数为NaN,则结果是NaN Infinity / Infinity，结果为NaN 0/0，结果为NaN 非0的有限数 / 0，结果为Infinity或者-Infinity Infinity / 有限数，结果为Infinity或者-Infinity 有一个数为非数值时先调用Number()转型函数将其转换为数值 总结：符号位取决于两个数值的符号，相同则为正数，不同则为负 求模(求余数) % Infinity % 有限数，结果为NaN 有限数 % Infinity,结果为有限数 有限数 % 0，结果为NaN Infinity % Infinity，结果为NaN 非数值时先调用Number()转型函数将其转换为数值 加性操作符加法 + 只要有一个是NaN,结果就是NaN 1NaN + 0; // NaN Infinity + -Infinity; 结果为 NaN -Infinity + -Infinity; 结果为 -Infinity Infinity + Infinity; 结果为 Infinity 0 + 0; 结果为 0 -0 + -0; 结果为 -0 +0 + -0; 结果为 +0 两个都是字符串，则将两个字符串拼接 一个是字符串另一个是对象、数值、布尔值，则先调用toString()将其转换成字符串在进行拼接，对于undefined和null，调用String()去的字符串’undefined’和’null’ 减法 -Infinity 减 -Infinity; 结果为 NaN Infinity 减 Infinity; 结果为 NaN -Infinity 减 Infinity; 结果为 -Infinity Infinity 减 -Infinity; 结果为 Infinity 0 减 0; 结果为 0 -0 减 -0; 结果为 0 -0 减 0; 结果为 -0 如果有一个操作符为字符串、布尔值、null或undefined。则先调用Number()将其转换 如果操作符为对象，先调用valueOf方法以取得该对象的数值，如果对象没有valueOf()则调用toString() 关系操作符 &gt; &lt; &lt;= &gt;=返回布尔值 两个都是数值，则执行数值比较 两个都是字符串，则比较对应的字符编码值 一个是数值，则将另一个先转化为数值，再执行数值比较大写字母全部小于小写字母，按每个字符比较：小写字母&gt;大写字母&gt;有效数值的字符串 123console.log('A' &gt; 'a'); // falseconsole.log('9' &gt; 'A'); // falseconsole.log('23' &lt; '3'); // true 任何值与NaN作比较都为false 相等操作符相等与不相等 ==先转换在比较 如果有一个是布尔值，则将其转换为数值在比较 如果一个是字符串，另一个是数值，则先将字符串转换为数值 如果有一个是对象，则调用对象的valueOf()再按前面的规则比较 null和undefined相等 在比较之前，不可以将 null和undefined转换成其他任何值 NaN和任何值都不相等 如果两个都是对象，则比较两个是不是指向同一对象 全等于不全等 ===不转换，直接比较 条件操作符即三元表达式 赋值操作符 =可结合 + - * / % &lt;&lt;=(左移) &gt;&gt;=(有符号位右移) &gt;&gt;&gt;=(无符号位右移) 逗号操作符可以在一条语句上执行多个操作12var a=10,b=20;console.log(20 === (a, b)); // false]]></content>
      <categories>
        <category>红皮书笔记--《JavaScript高级程序设计》</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[flex布局]]></title>
    <url>%2F2019%2F03%2F11%2FCSS%2Fflex%2F</url>
    <content type="text"><![CDATA[参考阮一峰-Flex布局教程：语法篇 Flex布局1234567891011121314151617// style.container&#123;&#125;.item&#123; width: 80px;height: 80px;text-align: center;font-weight: bold;line-height: 60px;&#125;.item:nth-of-type(1n)&#123;background-color: aqua&#125;.item:nth-of-type(2n)&#123;background-color:rgb(179, 116, 238)&#125;.item:nth-of-type(3n)&#123;background-color:rgb(230, 136, 70)&#125;.item:nth-of-type(4n)&#123;background-color:rgb(131, 224, 131)&#125;// body&lt;div class="container"&gt; &lt;div class="item"&gt;item 1&lt;/div&gt; &lt;div class="item"&gt;item 2&lt;/div&gt; &lt;div class="item"&gt;item 3&lt;/div&gt; &lt;div class="item"&gt;item 4&lt;/div&gt;&lt;/div&gt; 配置 display: flex;flex(flexible box)，任何元素都可以设为flex/inline-flex:12345// style.container&#123; display: -webkit-flex; /* Safari */ display: flex;&#125; 此时div.container为Flex容器(flex container)，它的所有子元素自动成为容器成员，成为Flex项目(Flex item)，简称“项目”。 容器的属性flex-direction 决定项目的排列方向flex-direction：row | row-reverse | column | column-reverse;默认值：row-主轴为水平方向，起点在左端设置flex-direction: column-reverse;(主轴为垂直方向，起点在下沿)。其它类推12345.container&#123; display: -webkit-flex; /* Safari */ display: flex; flex-direction: column-reverse;&#125; flex-wrap 决定是否换行以及第一行的位置flex-wrap：nowrap | wrap | wrap-reverse;默认值：nowrap-不换行配置flex-wrap：wrap-reverse;(换行，第一行在下方)其它类推1234567891011121314151617181920212223.container&#123; display: -webkit-flex; /* Safari */ display: flex; flex-direction: column-reverse; flex-wrap: wrap-reverse; width: 320px;height: 320px;&#125;// body&lt;div class="container"&gt; &lt;div class="item"&gt;item 1&lt;/div&gt; &lt;div class="item"&gt;item 2&lt;/div&gt; &lt;div class="item"&gt;item 3&lt;/div&gt; &lt;div class="item"&gt;item 4&lt;/div&gt; &lt;div class="item"&gt;item 5&lt;/div&gt; &lt;div class="item"&gt;item 6&lt;/div&gt; &lt;div class="item"&gt;item 7&lt;/div&gt; &lt;div class="item"&gt;item 8&lt;/div&gt; &lt;div class="item"&gt;item 9&lt;/div&gt; &lt;div class="item"&gt;item 10&lt;/div&gt; &lt;div class="item"&gt;item 11&lt;/div&gt; &lt;div class="item"&gt;item 12&lt;/div&gt;&lt;/div&gt; flex-flowflex-flow：flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap配置flex-flow: column-reverse wrap-reverse;1234567891011.container&#123; border: 1px solid #000; display: -webkit-flex; /* Safari */ display: flex; flex-flow: column-reverse wrap-reverse; /* 相当于: flex-direction: column-reverse; flex-wrap: wrap-reverse; */ width: 320px;height: 400px;&#125; justify-content 项目在主轴上的对齐方式justify-content：flex-start | flex-end | center | space-between | space-evenly | space-around ;1234567.container&#123; border: 1px solid #000; display: -webkit-flex; /* Safari */ display: flex; justify-content: flex-start; width: 400px;height: 100px;&#125; align-items 项目在交叉轴上如何对齐align-items：flex-start | flex-end | center | baseline | stretch；1234567.container&#123; border: 1px solid #000; display: -webkit-flex; /* Safari */ display: flex; justify-content: flex-start; width: 400px;height: 100px;&#125; 1234567891011121314.container&#123; border: 1px solid #000; display: -webkit-flex; /* Safari */ display: flex; align-items:baseline; width: 400px;height: 100px;&#125;.item&#123; width: 80px;height: 80px;text-align: center;font-weight: bold;line-height: 60px;&#125;.item:nth-of-type(1n)&#123;background-color: aqua;font-size: 36px&#125;.item:nth-of-type(2n)&#123;background-color:rgb(179, 116, 238);font-size: 12px&#125;.item:nth-of-type(3n)&#123;background-color:rgb(230, 136, 70)&#125;.item:nth-of-type(4n)&#123;background-color:rgb(131, 224, 131)&#125; align-content 多根轴线的对齐方式（多行）align-content：flex-start | flex-end | center | space-between | space-around | stretch； 如果项目只有一根轴线，该属性不起作用1234567.container&#123; border: 1px solid #000; display: -webkit-flex; /* Safari */ display: flex; flex-wrap: wrap; width: 500px;height: 300px;&#125; 项目的属性order 项目的排列顺序数值越小，排列越靠前，默认为0。可以为负数12345678910111213.container&#123; border: 1px solid #000; display: -webkit-flex; /* Safari */ display: flex; width: 400px;height: 100px; &#125; .item&#123; width: 80px;text-align: center;font-weight: bold;height: 80px; &#125; .item:nth-of-type(1n)&#123;background-color: rgb(2, 252, 252);order: 2;&#125; .item:nth-of-type(2n)&#123;background-color:rgb(179, 116, 238);order: 0;&#125; .item:nth-of-type(3n)&#123;background-color:rgb(230, 136, 70);order: 1;&#125; .item:nth-of-type(4n)&#123;background-color:rgb(131, 224, 131);order: 3;&#125; flex-grow 项目的放大比例默认为0，即如果存在剩余空间，也不放大,负值对该属性无效。1234.item:nth-of-type(1n)&#123;background-color: rgb(2, 252, 252);flex-grow:2;&#125;.item:nth-of-type(2n)&#123;background-color:rgb(179, 116, 238);flex-grow:1;&#125;.item:nth-of-type(3n)&#123;background-color:rgb(230, 136, 70);flex-grow:1;&#125;.item:nth-of-type(4n)&#123;background-color:rgb(131, 224, 131);flex-grow:0;&#125; flex-shrink 项目的缩小比例默认为1，即如果空间不足，该项目将缩小,负值对该属性无效。一个项目的flex-shrink属性为0，其他项目都为&gt;=1，则空间不足时，前者不缩小1234.item:nth-of-type(1n)&#123;background-color: rgb(2, 252, 252);flex-shrink:4;&#125;.item:nth-of-type(2n)&#123;background-color:rgb(179, 116, 238);flex-shrink:1;&#125;.item:nth-of-type(3n)&#123;background-color:rgb(230, 136, 70);flex-shrink:1;&#125;.item:nth-of-type(4n)&#123;background-color:rgb(131, 224, 131);flex-shrink:0;&#125; flex-basis 分配多余空间之前，项目占据的主轴空间（main size）默认值为：auto,即项目本来大小。只要设定了flex-auto那么项目的宽度最大值就会固定，当空间不够时缩小12345678910111213.container&#123; border: 1px solid #000; display: -webkit-flex; /* Safari */ display: flex; width:300px;height: 100px;&#125;.item&#123; width: 80px;text-align: center;font-weight: bold;height: 80px;flex-grow:1;&#125;.item:nth-of-type(1n)&#123;background-color: rgb(2, 252, 252);flex-basis:40px&#125;.item:nth-of-type(2n)&#123;background-color:rgb(179, 116, 238);flex-basis:80px&#125;.item:nth-of-type(3n)&#123;background-color:rgb(230, 136, 70);&#125;.item:nth-of-type(4n)&#123;background-color:rgb(131, 224, 131);&#125; flexflex: none | auto | [ &lt;’flex-grow’&gt; &lt;’flex-shrink’&gt;? || &lt;’flex-basis’&gt; ]flex属性是flex-grow, flex-shrink 和 flex-basis的简写，默认值为(0,1,auto),两个快捷值：auto(1 1 auto) 和 none (0 0 auto) align-selfalign-self: auto | flex-start | flex-end | center | baseline | stretch; 允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。 项目的高度如果固定为height:xxpx;那么align-items:stretch以及align-self:stretch无效]]></content>
      <tags>
        <tag>flex布局</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[提升机制]]></title>
    <url>%2F2019%2F03%2F11%2FJS%2Fpromote%2F</url>
    <content type="text"><![CDATA[一次群里的讨论引发的思考问题：以下代码会输出什么？1234567var getName = function() &#123; console.log(1)&#125;function getName() &#123; console.log(2)&#125;getName() 开始我以为会是2，因为后面的代码会覆盖前面的，但是答案往往会偏离我们的想法ε=(´ο｀*)))唉。看了群里的大神提了一句：函数提升 优于变量，开始思考提升机制。 函数提升优于变量提升这句话没毛病，红皮书111页说道：解析器在向执行环境中加载数据时会率先读取函数声明，并使其在执行任何代码之前可用(可访问)，即函数声明提升、JavaScript上卷中第40页提到函数声明是优于变量提升的。可见代码12345console.log(getName)var getName = 1;function getName() &#123; console.log(2)&#125; 输出为函数getName,代码等价于12345function getName() &#123; console.log(2)&#125;console.log(getName);getName = 1; 问题升级先来看代码：1234567891011121314151617/* * 函数声明优于变量声明* 函数表达式会将变量提升，但是代码在执行的时候才会被赋值*/test();console.log(test);function test() &#123; console.log('我是函数');&#125;console.log(test);var test = '我是变量';console.log(test);var test = function (params) &#123; console.log('我是函数表达式');&#125;console.log(test);test(); 这次，我加入了函数表达式，结果如下：解释：函数声明优于变量声明，所以第一个console.log(test)会输出函数test(),test()输出’我是函数’。而变量只有当代码执行到该语句的时候才会被赋值并且覆盖内存。所以第三个console.log(test)输出的是变量’我是变量’。最后函数表达式又覆盖了前面的代码，所以最后一个console.log(test)输出函数表达式test()，test()输出’我是函数表达式’。代码等价于12345678910111213function test() &#123; console.log('我是函数');&#125;test();// 第一次调用console.log(test); // 第一次console.logconsole.log(test); // 第二次console.logtest = '我是变量';console.log(test);test = function (params) &#123; console.log('我是函数表达式');&#125;console.log(test);test(); 如果活动对象上已经存在属性名称，解析器就会绕过该声明。即因为函数声明优先于变量声明，因此活动对象(window)不会再注册一个test了。谢谢call_me_R的提醒 再升一级这次，我把代码顺序调换一下12345678910111213test();console.log(test);var test = '我是变量';console.log(test);var test = function (params) &#123; console.log('我是函数表达式');&#125;console.log(test);function test() &#123; console.log('我是函数');&#125;console.log(test);test(); 结果如下：这次我将函数声明放到了最下面，但是却没有最后一次执行test()输出的却是我是函数表达式。解释：函数在提升的时候解析器就已经解析过一遍了，代码执行到函数这里不会再次解析也就不会再次赋值。因此就不会出现覆盖前面代码这一说。代码等价于12345678910111213function test() &#123; console.log('我是函数');&#125;test();console.log(test);test = '我是变量';console.log(test);test = function (params) &#123; console.log('我是函数表达式');&#125;console.log(test);console.log(test);test(); 注意：不要学了一点就忘记别的了啊，如果两个函数名一样，后面的会覆盖前面的(认为是在函数解析的时候覆盖，即提升的时候就覆盖了) 12345678910console.log(test);function test() &#123; console.log('我是函数');&#125;console.log(test);function test() &#123; console.log('我是函数表达式');&#125;console.log(test);test(); 结果：]]></content>
      <tags>
        <tag>原创</tag>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[迭代器(Iterator)和生成器(Generator)]]></title>
    <url>%2F2019%2F03%2F08%2FES6-8%2F</url>
    <content type="text"><![CDATA[迭代器为什么要增加迭代器？循环语句迭代数据时，需要初始化一个变量来跟踪数组/数据集合的索引，eg:for循环中的i记录数组的索引。如果多个循环嵌套那么会使得程序复杂度增加，也容易出错。 什么是迭代器？迭代器是一个特殊对象，具有一些专门为迭代过程设计的专有接口，所有的迭代器对象都有一个next()方法，每次调用都返回一个结果对象，其中包含2个属性： value：表示下一个将要返回的值 done：布尔值，当没有更多可返回的值的时候为true,否则为false 迭代器还会保存一个内部指针，指向当前集合中值的位置。每次调用next()方法都返回下一个可用的值12345678910111213141516171819// ES5 实现迭代器function createIterator(items) &#123; var i = 0; return &#123;next:function()&#123; var done = (i &gt;= items.length); var value = !done?items[i++]:undefined; return&#123; value, done &#125; &#125; &#125;&#125;var iterator = createIterator([1,2,3]);console.log(iterator);console.log(iterator.next());console.log(iterator.next());console.log(iterator.next());console.log(iterator.next()); ES6中迭代器的编写程序也很复杂，所以ES6还引入了一个生成器，简化创建迭代器的过程 生成器生成器是一种返回迭代器的函数，通过function关键字后面的星号(*)来表示，函数中也会用到新的关键字yield。 关键字yield是ES6中的新特性,并且只能在生成器内部使用，在其他地方使用会导致程序出错，即使是在生成器内部的函数也是如此。因为它与return一样，都不能穿透函数边界，嵌套函数中的return语句不能作为外部函数的返回语句。12345function *createIterator(items) &#123; items.forEach(item =&gt; &#123; yield item + 1 ; // Uncaught SyntaxError: Unexpected identifier &#125;);&#125; 可以使用yield来指定调用迭代器的next()方法时的返回值及返回顺序，每执行完一条yield语句后函数就会自动停止，下次在运行时继续执行后面的语句 1234567891011function *createIterator(items) &#123; for (let i = 0; i &lt; items.length; i++) &#123; yield items[i]; &#125;&#125;var iterator = createIterator([1,2,3]);console.log(iterator);console.log(iterator.next());console.log(iterator.next());console.log(iterator.next());console.log(iterator.next()); 12345678910function *createIterator(items) &#123; for (let i = 0; i &lt; items.length; i++) &#123; yield items[i]; &#125;&#125;var iterator = createIterator([1,2,3]);console.log(iterator);console.log(iterator.next());console.log(iterator.next());console.log(iterator.next()); 从两次的结果中可以看出，当for循环完之后再次调用next()方法时，[[GeneratorStatus]]: “closed”(关闭)。否则，[[GeneratorStatus]]: “suspended”(挂起) 生成器函数表达式此时createIterator()是一个生成器函数表达式，而不是一个函数声明。12345let createIterator = function *(items) &#123; for (let i = 0; i &lt; items.length; i++) &#123; yield items[i]; &#125; &#125;; 不能用箭头函数来创建生成器 生成器对象的方法生成器本身就是函数12345678910111213let o = &#123; createIterator : function* (items) &#123; for (let i = 0; i &lt; items.length; i++) &#123; yield items[i]; &#125; &#125;, // 或者 *createIterator(items) &#123; for (let i = 0; i &lt; items.length; i++) &#123; yield items[i]; &#125; &#125; &#125; 可迭代对象和for-of循环可迭代对象：可迭代对象具有Symbol.iterator属性，该属性通过指定的函数可以返回一个作用于附属对象的迭代器。ES6中，所有的集合对象(数组、Set集合、Map集合)和字符串都是可迭代对象，这些对象都有默认的迭代器，ES6中的新特性for-of循环需要用到可迭代对象的这些功能。 由于生成器默认会为Symbol.iterator属性赋值，因此所有通过生成器创建的迭代器都是可迭代对象 for-of循环每执行一次都会调用可迭代对象的next()方法，并将迭代器返回的结果对象的value属性存储在一个变量中，循环将持续到返回对象的done属性值为true1234var values = [1,2,3];for (const num of values) &#123; console.log(num) // 1 2 3&#125; 如果将for-of语句用于不可迭代对象、null或者undefined将会导致程序抛出错误 for-in、for-of、forEach for-in：返回所有能够通过对象访问的，可枚举的属性，其中包括存在于实例中的属性 for-of：只可以用于可迭代对象，每次调用next()方法都返回一个包含value和done的数组，并将value保存到自定义的变量中。eg:for(let num of colors){},value保存在num变量里 forEach：与for循环迭代类似,对数组中的每一项给定函数，还可以指定作用域，不遍历数组的私有属性 访问默认迭代器通过Symbol.iterator获取默认迭代器：123456var values = [1,2,3];var iterator = values[Symbol.iterator]();console.log(iterator);console.log(iterator.next());console.log(iterator.next());console.log(iterator.next()); 检测对象是否为可迭代对象123456789function isIterator(object) &#123; return typeof object[Symbol.iterator] === 'function'&#125;console.log(isIterator([1, 2, 3])); // trueconsole.log(isIterator('Silvia')); // trueconsole.log(isIterator(new Map())); // trueconsole.log(isIterator(new Set())); // trueconsole.log(isIterator(new WeakSet())); // falseconsole.log(isIterator(new WeakMap())); // false 创建可迭代对象默认情况下，对象是不可迭代对象，但是可以通过给Symbol.iterator属性添加一个生成器使其变为可迭代对象123456789101112let collection = &#123; items:[1,2,3], *[Symbol.iterator]()&#123; console.log(this); for (let item of this.items)&#123; yield item &#125; &#125;&#125;for (const x of collection) &#123; console.log(x); // 1 2 3&#125; 内建迭代器集合对象迭代器ES6中的3中集合对象：数组、Set集合、Map集合。它们都内建了以下三种迭代器： entries()：返回一个迭代器，其值为多个键值对 values()：返回一个迭代器，其值为集合的值 keys()：返回一个迭代器，其值为集合中所有键名 entries()每次调用next()时，entries()迭代器都会返回一个数组，数组中的两个值分别代表集合中每个元素的键与值。如果遍历的是数组，则第一个元素为数字类型的索引；如果遍历的是Set集合，则第一个元素与第二个元素都是值；如果遍历的是Map集合，则第一个元素为键名：12345678910111213let coloes = ['red','blue','green'];let tracking = new Set([123,456,789]);let user = new Map([['name','Silvia'],['age',25]]);for (const entry of coloes.entries()) &#123; console.log(entry)&#125;for (const entry of tracking.entries()) &#123; console.log(entry)&#125;for (const entry of user.entries()) &#123; console.log(entry)&#125; values()迭代器12345678910111213let coloes = [&apos;red&apos;,&apos;blue&apos;,&apos;green&apos;];let tracking = new Set([123,456,789]);let user = new Map([[&apos;name&apos;,&apos;Silvia&apos;],[&apos;age&apos;,25]]);for (const entry of coloes.values()) &#123; console.log(entry)&#125;for (const entry of tracking.values()) &#123; console.log(entry)&#125;for (const entry of user.values()) &#123; console.log(entry)&#125; keys()迭代器如果遍历的是数组，则返回数字类型的键，数组本身的其他属性不会被返回；如果遍历的是Set集合，返回值与values()的相同；如果遍历的是Map集合，则返回每个独立的键：12345678910111213let coloes = ['red','blue','green'];coloes.name = 'myColor'; // 数组的私有属性，let tracking = new Set([123,456,789]);let user = new Map([['name','Silvia'],['age',25]]);for (const entry of coloes.keys()) &#123; console.log(entry)&#125;for (const entry of tracking.keys()) &#123; console.log(entry)&#125;for (const entry of user.keys()) &#123; console.log(entry)&#125; 不同集合的默认迭代器for-of中没有显示指定则使用默认迭代器，数组和Set集合：values(),Map集合：entries() for-of可以和解构一起用12345678let user = new Map([['name','Silvia'],['age',25]]);let tracking = new Set([123,456,789]);for (const [key,value] of tracking.entries()) &#123; console.log(key+'='+value)&#125;for (const [key,value] of user) &#123; console.log(key+'='+value)&#125; 字符串迭代器NodeList迭代器1234var divs = document.getElementsByTagName('div');for(let div of divs)&#123; console.log(div.id)&#125; 展开运算符与非数组可迭代对象展开运算符将集合所有的值填充到了一个数组的字面量里，可以操作所有可迭代对象，并根据默认迭代器来选取要引用的值，从迭代器读取所有值。然后按照返回顺序将它们依次插入到数组中12345678910let tracking = new Set([123,456,789]);let array_tracking = [...tracking];let user = new Map([['name','Silvia'],['age',25]]);let array_user = [...user];console.log(array_tracking); // [123, 456, 789]console.log(array_user); // [["name", "Silvia"],["age", 25]let smallNumbers = [1,2,3];let bigNumbers = [100,101,102];let allNumbers = [0,...smallNumbers,...bigNumbers]console.log(allNumbers); [0, 1, 2, 3, 100, 101, 102] 高级迭代器功能给迭代器传递参数既可以用迭代器的next()方法返回值，也可以在生成器内部使用yield关键字来生成值。如果给迭代器的next()方法传递参数，则这个参数会代替生成器内部上一条yield语句的返回值12345678910function *createIterator() &#123; let first = yield 1; let second = yield first+2; yield second+3;&#125;let iterator = createIterator();console.log(iterator.next(2)); // &#123;value: 1, done: false&#125;console.log(iterator.next(4)); // &#123;value: 6, done: false&#125;console.log(iterator.next(5)); // &#123;value: 5, done: false&#125;console.log(iterator.next(2)); // &#123;value: undefined, done: true&#125; 有结果可知，第一次调用next()传入参数被忽略，因为第一次没有可替代的上一条yield语句的返回值 在迭代器中抛出错误通过将错误对象传给throw(),生成器在执行时会抛出错误123456789function *createIterator() &#123; let first = yield 1; let second = yield first+2; yield second+3;&#125;let iterator = createIterator();console.log(iterator.next(2)); // &#123;value: 1, done: false&#125;console.log(iterator.next(4)); // &#123;value: 6, done: false&#125;console.log(iterator.throw(new Error('Boom'))); // Uncaught Error: Boom 这与直接抛出错误类似，只是时机不同。可以在生成器内通过try-catch捕获错误123456789101112131415function *createIterator() &#123; let first = yield 1; let second; try &#123; second = yield first + 2; &#125; catch (error) &#123; second = 6 &#125; yield second+3;&#125;let iterator = createIterator();console.log(iterator.next(2)); // &#123;value: 1, done: false&#125;console.log(iterator.next(4)); // &#123;value: 6, done: false&#125;console.log(iterator.throw(new Error('Boom'))); // &#123; value: 9, done: false &#125;console.log(iterator.next(2)); // &#123;value: undefined, done: true&#125; 生成器返回语句生成本身就是函数，因为可以通过return提前退出函数执行。return 语句返回值会被赋值给value属性，同时done属性设置为true。之后的yield语句不会在被执行1234567891011function *createIterator() &#123; let first = yield 1; return 42; let second = yield first+2; yield second+3;&#125;let iterator = createIterator();console.log(iterator.next(2)); // &#123;value: 1, done: false&#125;console.log(iterator.next(4)); // &#123;value: 42, done: true&#125;console.log(iterator.next(5)); // &#123;value: undefined, done: true&#125;console.log(iterator.next(2)); // &#123;value: undefined, done: true&#125; 展开运算符与for-of循环语句会直接忽略通过return语句指定的任何返回值，只要done为true就立即停止读取其它值 委托生成器给yield语句添加一个星号，就可以将生成数据的过程委托给其他生成器1234567891011121314151617181920function *createNumberIterator() &#123; yield 1; yield 2;&#125;function *createColorIterator() &#123; yield 'red'; yield 'blue';&#125;function *createCombinedIterator() &#123; yield *createNumberIterator(); yield *createColorIterator(); yield true&#125;var iterator = createCombinedIterator();console.log(iterator.next()); // &#123;value: 1, done: false&#125;console.log(iterator.next()); // &#123;value: 2, done: false&#125;console.log(iterator.next()); // &#123;value: 'red', done: false&#125;console.log(iterator.next()); // &#123;value: 'blue', done: false&#125;console.log(iterator.next()); // &#123;value: true, done: false&#125;console.log(iterator.next()); // &#123;value: undefined, done: true&#125; 可以将return语句与委托生成器结合在一起用1234567891011121314151617181920212223function *createNumberIterator() &#123; yield 1; yield 2; return ['red','blue','green']&#125;function *createColorIterator(count) &#123; for (let i = 0; i &lt; count.length; i++) &#123; yield count[i]; &#125;&#125;function *createCombinedIterator() &#123; let result = yield *createNumberIterator(); yield *createColorIterator(result); yield true&#125;var iterator = createCombinedIterator();console.log(iterator.next()); // &#123;value: 1, done: false&#125;console.log(iterator.next()); // &#123;value: 2, done: false&#125;console.log(iterator.next()); // &#123;value: 'red', done: false&#125;console.log(iterator.next()); // &#123;value: 'blue', done: false&#125;console.log(iterator.next()); // &#123;value: "green", done: false&#125;console.log(iterator.next()); // &#123;value: true, done: false&#125;console.log(iterator.next()); // &#123;value: undefined, done: true&#125; yield也可以直接应用于字符串,将使用字符串的默认迭代器12345678910function *createNumberIterator() &#123; yield * 'hello'&#125;var iterator = createNumberIterator();console.log(iterator.next()); // &#123;value: 'h', done: false&#125;console.log(iterator.next()); // &#123;value: 'e, done: false&#125;console.log(iterator.next()); // &#123;value: 'l', done: false&#125;console.log(iterator.next()); // &#123;value: 'l', done: false&#125;console.log(iterator.next()); // &#123;value: "o", done: false&#125;console.log(iterator.next()); // &#123;value: undefined, done: true&#125; 异步任务执行（这里比较难理解，先简单记录例子）先看一个读取文件的例子(node)12345678let fs = require('fs');fs.readFile('config.js',function(err,contents)&#123; if(err)&#123; throw err &#125; doSomthingWith(contents); console.log('done');&#125;); 读取文件fs()方法传入一个文件名和一个回调函数，调用回调函数的时候会检查是否有错误，有则抛出否则执行下面的语句。 简单任务的执行器为了避免每执行一次yield语句就会暂停并等待下一次调用，可以创建一个函数，在函数中调用生成器生成相应的迭代器，从而在不用回调函数的基础上实现异步调用next()123456789101112131415function run(taskDef) &#123; // 创建一个无限使用的迭代器 let task = taskDef(); // 开始执行任务 let result = task.next(); // 循环调用next() function step() &#123; // 如果任务未完成 if(!result.done)&#123; result = task.next(); step() &#125; &#125; step();&#125; 向任务执行器传递数据通过给迭代器的next()方法传值生成器内部上一条yield语句的返回值，只要将值(result.value)传入next()即可 异步任务执行器理解：任务执行器需要知道回调函数是什么？如何使用回调函数？yield表达式会将值返回给任务执行器，所有的函数调用都会返回一个值，因而在某种程序上也是一个异步操作。通过添加定时器时期便为异步函数1234567function fetchData() &#123; return function (callback) &#123; setTimeout(() =&gt; &#123; callback(null, 'Hi') &#125;, 50); &#125;&#125; 应用：123456789101112131415161718192021222324252627function run(taskDef) &#123; // 创建一个无限使用的迭代器 let task = taskDef(); // 开始执行任务 let result = task.next(); // 循环调用next() function step() &#123; // 如果任务未完成 if (!result.done) &#123; if(typeof result.value === 'function')&#123; result.value(function (err,data) &#123; if(err)&#123; result = task.throw(err); return &#125; result = task.next(); step() &#125;); &#125;else&#123; result = task.next(result.value); step() &#125; &#125; &#125; // 开始迭代执行 step();&#125; 上面的读取文件的方法改写：1234567891011let fs = require('fs');function readFile(fileName)&#123; return function(callback)&#123; fs.readfile(fileName,callback) &#125;&#125;run(function *()&#123; let contents = yield readFile('config.json'); dosomthing(); console.log('done');&#125;);]]></content>
      <categories>
        <category>《深入理解ES6》--笔记</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Set集合与Map集合]]></title>
    <url>%2F2019%2F03%2F05%2FES6%2FSetAndMap%2F</url>
    <content type="text"><![CDATA[英文原版：Understanding ECMAScript 6 ECMAScript5中的Set集合与Map集合12345678910var set = Object.create(null);set.foo=true;if(set.foo)&#123; console.log('set.foo 存在'); // set.foo 存在&#125;var map = Object.create(null);map.foo = "bar";var value = map.foo;console.log('map.foo:',value); // map.foo: bar Set集合一般用于检测对象中是否存在某个键名，Map集合常用于获取已存的信息 缺陷： 属性名会强制转换为字符串 对象的属性名为对象时会自动转化为[object Object] 用于检测某一属性是否存在时模棱两可。eg:set.count=0;if(set.count){//将不会触发} ECMAScript6中的Set集合ECMAScript6中新增的Set类型是一种有序列表,其中含有一些相互独立的非重复值，通过Set集合可以快速访问其中的数据，更有效的追踪各种离散值 创建Set集合并添加元素Set()相关方法及属性： new Set()可创建Set集合- 调用add()方法可以向集合添加元素 has()方法可检测Set集合中是否含有某元素 size属性可获取集合中目前的元素数量 也可以通过数组来初始化Set集合，此时Set构造函数会过滤掉重复的值从而保证集合中的元素各自唯一 delete()可移除某一个元素 clear()会移除集合中的所有元素 123456789101112let set = new Set();let set2 = new Set([1,2,3,4,5,5,6,7]);set.add(5);set.add('5');set.has('5'); // trueconsole.log(set.size); // 2console.log(set2.size); // 7set2.delete(5);console.log(set2.size); // 6set2.clear();console.log(set2.size); // 0 Set集合特点; 集合中的元素各自唯一 不会强制转换所存值的类型 Set集合中的元素独立存在 多次调用add()并传入相同参数时，后续的调用会被忽略 Set集合的forEach()方法Set集合的forEach()方法与数组的forEach()方法运行机制类似，其回调函数接收以下三个参数： Set集合中下一次索引的位置 与第一个参数一样的值 被遍历的Set集合本身 12345let set3 = new Set([0,2]);set3.forEach((value,key,ownerSet) =&gt; &#123; console.log(value+" "+key); console.log(set3 === ownerSet);&#125;); 结果：12340 0true2 2true Set集合的forEach()与this:123456789101112131415161718192021222324252627// 箭头函数let set3 = new Set([0,2]);let processor = &#123; output(value)&#123; console.log(value); &#125;, process(dataSet)&#123; dataSet.forEach(value =&gt; &#123; // this指向processor this.output(value) &#125;); &#125;&#125;processor.process(set3)// 或者this绑定let set3 = new Set([0,2]);let processor = &#123; output(value)&#123; console.log(value); &#125;, process(dataSet)&#123; dataSet.forEach(function(value) &#123; this.output(value) &#125;,this); // forEach的第二个参数：作为该执行回调时使用的对象 &#125;&#125;processor.process(set3) Set集合不可以像访问数组元素那样直接通过索引访问集合中的元素，如有需要，需将Set转换为数组 Set集合转换为数组数组转换为Set: 将数组传入构造函数Set转换为数组: 使用展开运算符(…),可以将数组中的元素分解为各自独立的参数传给函数，也可以将诸如Set集合的可迭代对象转换为数组123let set = new Set([1,2,3,3,3,4]), arr = [...set];console.log(arr); // [1,2,3，4] Weak Set集合Set集合是一个强引用，只要Set实例中的引用存在，垃圾回收机制就不能释放该对象的内存空间1234567let set = new Set(),key=&#123;&#125;;set.add(key);console.log(set.size); // 1 key = null;console.log(set.size); // 1key = [...set][0];console.log(key); // &#123;&#125; Weak Set：弱引用Set集合只存储对象的弱引用，不存储原始值。集合中的弱引用如果是对象唯一的引用，则会被回收并释放相应内存 创建Weak Set集合创建：new WeakSet()。集合支持3个方法：add()、has()、delete()12345678let set = new WeakSet(),key=&#123;&#125;,test=&#123;&#125;;set.add(key);set.add(test);console.log(set.has(key)); // trueset.delete(key)test = null;console.log(set.has(key)); // falseconsole.log(set.has(test)); // false Weak Set集合不接受任何原始值，如果传入new WeakSet()的数组中有其他非对象值，程序会报错和Set集合的差别： Weak Set集合不接受任何原始值，如果向new WeakSet()/add()/has()/delete()传入非对象值，程序会报错 Weak Set集合不可迭代，所以不能用于for-of Weak Set集合不暴露任何迭代器,eg：keys()/values()。所以不能通过程序本身来检测其中的内容 Weak Set集合不支持forEach() Weak Set集合不支持size属性 ECMAScript6中的Map集合ECMAScript6中的Map类型是一个储存着许多键值对的有序列表，其中键名和对应的值支持所有的数据类型。键名的等价性判断通过Object.is()方法实现 Map集合支持的方法及属性 创建：new Map() 添加：set() 获取：get() 检测指定键名是否存在：has() 删除某一键值对：delete() 清空所有键值对：clear() 长度：size属性 12345678910111213141516171819let map = new Map();map.set('title','ES6');map.set('year',2016);console.log(map.size); // 2console.log(map.has('title')); // trueconsole.log(map.get('title')); // ES6console.log(map.has('year')); // trueconsole.log(map.get('year')); // 2016map.delete('title');console.log(map.size); // 1console.log(map.has('title')); // falseconsole.log(map.has('year')); // trueconsole.log(map.get('year')); // 2016map.clear();console.log(map.size); // 0console.log(map.has('title')); // falseconsole.log(map.has('year')); // false Map集合初始化1234567// 初始化let map2 = new Map([['name','Silvia'],['age',25]]);console.log(map2.size); // 2console.log(map2.has('name')); // trueconsole.log(map2.get('name')); // Silviaconsole.log(map2.has('age')); // trueconsole.log(map2.get('age')); // 25 Map集合的forEach()方法Map集合的forEach()方法与Set集合和数组的forEach()方法运行机制类似，其回调函数接收以下三个参数： Map集合中下一次索引的位置 值对应的键名 被遍历的Map集合本身 与数组forEach()的区别：Map的会按照插入Map集合的顺序将相应的信息传入forEach方法的回调函数，而在数组中会按照数值型索引值的顺序一次传入回调函数 可以指定forEach的第二个参数作为回调函数的this值 Weak Map集合ES6的Weak Map类型是一种储存着许多键值对的无序列表，列表的键名必须是非null的对象，键名对应的值可以是任何类型的值 使用Weak Map集合 创建：new WeakMap(), 添加：set() 获取：get() 检测：has() 删除：delete() 不支持键名枚举，从而不支持clear() 不支持size属性 私有对象数据Weak Map集合可以用来储存对象实例的私有数据。ES5中：12345678910111213141516var Person = (function () &#123; var privateData = &#123;&#125;, privateId = 0; function Person(name) &#123; console.log(this); // 指向当前调用的对象 Object.defineProperty(this,'_id',&#123;value:privateId++&#125;); // _id加1 privateData[this._id] = &#123;name:name&#125; &#125; Person.prototype.getName = function() &#123; return privateData[this._id].name &#125;; return Person;&#125;)();var person_ = new Person('Silvia');console.log(person_.getName()) // Silviaconsole.log(person_._id) // 0 存在缺陷：如果不主动管理，无法获知对象实例何时被销毁，因此privateData中的数据永远不会被销毁。而Weak Map可以解决这个问题：12345678910111213var Person = (function () &#123; var privateData = new WeakMap(); function Person(name) &#123; console.log(this); // 指向当前调用的对象 privateData.set(this,&#123;name:name&#125;) &#125; Person.prototype.getName = function() &#123; return privateData.get(this).name &#125;; return Person;&#125;)();var person_ = new Person('Silvia');console.log(person_.getName()) // Silvia Person对象的实例直接作为集合的键使用，从而代替了私有属性_id Weak Map 与 Map的选取Weak Map：当只用对象作为集合的键名时优先使用Map：当一定要用forEach/size/clear()来管理集合时使用，但需要注意内存的使用情况]]></content>
      <categories>
        <category>《深入理解ES6》--笔记</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Symbol]]></title>
    <url>%2F2019%2F03%2F04%2FES6%2Fsymbol%2F</url>
    <content type="text"><![CDATA[英文原版：Understanding ECMAScript 6 Symbol的由来ES6之前，无论属性名由什么元素构成，都通过一个字符串类型的名称来访问所有属性。私有名称原本是为了让开发者们创建非字符串属性名称而设计，但是检测这些私有名称很难实现。最终私有名称演变成ES6中的Symbol。 创建 Symbol创建Symbol时,可接收一个可选参数，可以添加一段文本描述即将创建的Symbol。该描述被储存在内部的[[Description]]属性中，不可用与属性访问，只有当调用Symbol的toString()方法时才可以读取这个属性。在执行console.log时隐式调用了Symbol的toString()方法，不能直接在代码里访问[[Description]]。123456789101112let firstName = Symbol('first name');let secondName = Symbol('second name');let person = &#123;&#125;;person[firstName] = 'Silvia';person.secondName = 'Jessie'console.log(person[firstName]); // Silviaconsole.log(person.firstName); // undefinedconsole.log(person[secondName]); // undefinedconsole.log(person.secondName); // Jessieconsole.log(typeof firstName); // symbolconsole.log(typeof secondName); // symbolconsole.log(secondName); // Symbol(second name) Symbol()为全局函数，创建Symbol并用它将一个新的属性赋值给person对象。当访问这个属性时一定要用最初定义的Symbol。可以通过typeof操作符来检测是否为Symbol类型 因为Symbol是原始值，所以new Symbol会导致程序报错 使用方法 前面提到的 [] 中使用Symbol 可计算对象字面量属性名 Object.definePropert()和Object.defineProperties()123456789101112131415let firstName = Symbol('first name');let person = &#123; [firstName]: 'Silvia'&#125;;Object.defineProperty(person,firstName,&#123;writable:false&#125;);let lastName = Symbol('last name');Object.defineProperties(person,&#123; [lastName]:&#123; value:'Zakas', writable:false &#125;&#125;);person[firstName] = 'Jessie'console.log(person[firstName]); // Silviaconsole.log(person[lastName]); // Zakas Symbol 共享体系为了能够在代码库中或跨文件追踪Symbol,ES6提供了一个可以随时访问的全局Symbol注册表。可以调用Symbol.for()方法，它只接收一个参数，也就是即将创建的Symbol的字符串标识符，也被用作Symbol的描述12345let uid = Symbol.for('uid');let obj = &#123;&#125;;obj[uid] = '123456';console.log(obj[uid]); // 123456console.log(uid); // Symbol(uid) Symbol.for()首先在全局Symbol注册表中搜索键为’uid’的Symbol是否存在，存在则返回已有的Symbol，否则创建一个新的Symbol,并使用这个键在Symbol全局注册表中注册，随机返回新创建的Symbol123456789let uid = Symbol.for('uid');let obj = &#123;&#125;;obj[uid] = '123456';let uid2 = Symbol.for('uid');console.log(obj[uid]); // 123456console.log(uid); // Symbol(uid)console.log(uid === uid2); // trueconsole.log(obj[uid2]); // 123456console.log(uid2); ; // Symbol(uid) 还可以调用Symbol.keyFor()方法在Symbol全局注册表中检索与Symbol有关的键123456let uid = Symbol.for('uid');let uid2 = Symbol.for('uid');let uid3 = Symbol();console.log(Symbol.keyFor(uid)); // uidconsole.log(Symbol.keyFor(uid2)); // uidconsole.log(Symbol.keyFor(uid3)); // undefined Symbol与类型强制转换JavaScript中在特定场景下可以将某个数据强制转换为其他类型的数据–自动转型。但是其他类型没有与Symbol逻辑等价的值，尤其不能将Symbol强制转换为字符串和数字类型。可以通过调用String()方法输出字符串形式的Symbol:123456789101112let uid = Symbol();let desc = String(uid)console.log(desc); // Symbol(uid)// 强制转换为字符串let descStr = uid+''; // 报错 Uncaught TypeError: Cannot convert a Symbol value to a string// 墙绘转换为数值let sum = uid / 1; // 报错 ES5.JS:85 Uncaught TypeError: Cannot convert a Symbol value to a number// 逻辑操作if(uid)&#123; console.log(desc); // Symbol(uid)&#125; String()方法调用了uid.toString()方法。Symbol不能被转换为字符串或者数值类型，但是其与非空值类似，等价布尔值为true,即可用于逻辑判断 Symbol 属性检索Object.keys()和Object.getOwnPropertyName()可以检索对象中所有的属性名：Object.keys()返回所有可枚举的属性名，Object.getOwnPropertyName()不考虑可枚举性一律返回。为了保持ES5函数的原有功能，这两个方法都不支持Symbol属性，而是添加了一个Object.getOwnPropertySymbols()方法来检索对象中的Symbol属性。12345678let uid = Symbol.for('uid');let person = &#123; [uid] : '123456'&#125;let symbols = Object.getOwnPropertySymbols(person);console.log(symbols.length); // 1console.log(symbols[0]); // Symbol(uid)console.log(obj[symbols[0]]); // 123456 对象可以通过原型链继承Symbol属性 通过well-known Symbol暴露内部操作ES6开放了以前JavaScript中常见的内部操作，并通过预定义一些well-known Symbol来表示，每一个这类Symbol都是Symbol对象的一个属性。这些well-known Symbol有： Symbol.hasInstance Symbol.isConcatSpreadable Symbol.match：在调用String.prototype.match()时调用 Symbol.replace：在调用String.prototype.replace()时调用 Symbol.search：在调用String.prototype.search()时调用 Symbol.split：在调用String.prototype.split()时调用 Symbol.toPrimitive方法：返回对象原始值的方法 Symbol.toStringTag属性:在调用Object.prototype.toString()方法时使用的字符串，用于创建对象描述 Symbol.unscopables属性：定义了一些不可被with语句引用对象属性名称的对象合集 Symbol.hasInstance方法在执行instanceof时调用的内部方法，用于检测对象的继承信息–确定对象是否为函数的实例。该方法在Function.prototype中定义，所以所有的函数都继承instanceof的默认行为。Symbol.hasInstance不可写、不可配置并且不可枚举。Symbol.hasInstance只接受一个参数，即要检查的值，如果传入的是函数的实例则返回true123obj instanceof Array;// 等价于Array[Symbol.hasInstance](obj); 可以通过Object.defineProperty()方法改写Symbol.hasInstance为不可写的属性，但是实际上objF还是MyObj的实例123456789function MyObj(params) &#123;&#125;Object.defineProperty(MyObj, Symbol.hasInstance, &#123; value:function (v) &#123; return false &#125;&#125;);let objF = new MyObj();console.log(objF instanceof MyObj); // falseconsole.log(MyObj.prototype.isPrototypeOf(objF)); // true Symbol.isConcatSpreadable属性JavaScript的concat()方法用于拼接两个数组123let color1 = ['red','blue'], color2 = ['white','green'];console.log(color1.concat(color2,'brown')) // ['red','blue','white','green','brown'] 传入的是数组则会将数组的每一项逐个加入color1的末尾，ES6以前不可改变这个特性。ES6中新增Symbol.isConcatSpreadable属性，用于表明属性值是否作为独立元素加入到数组中。值为true表明独立添加，false表明整个对象添加到数组12345678let collection = &#123; 0:'Hello', 1:'world', length:2, [Symbol.isConcatSpreadable]:true&#125;let messages = ['Hi'].concat(collection)console.log(messages) // ['Hi','Hello','world'] Symbol.match、Symbol.replace、Symbol.search和Symbol.split属性JavaScript中字符串有以下几个方法： match(regex)：确定给定字符串是否匹配正则表达式regex replace(regex,replacement)：将字符串中匹配正则表达式regex的部分替换成replacement search(regex)：在字符串中定位匹配正则表达式regex的位置索引 split(regex)：按照匹配正则表达式rege的元素将字符串分割，并将结果传入数组返回 可以在对象中定义Symbol.match、Symbol.replace、Symbol.search和Symbol.split属性，实现模拟匹配 Symbol.toPrimitive方法Symbol.toPrimitive被定义在每一个标准类型的原型上，并规定对象被转换为原始值时应当执行的操作对于大多数标准对象，数字模式转换优先级为： 调用valueOf()方法，如果结果为原始值，则返回 否则，调用toString()方法，如果结果为原始值，则返回 如果再无可选值，则抛出错误 对于大多数标准对象，字符串模式转换优先级为： 调用调用toString()方法，如果结果为原始值，则返回 否则，valueOf()方法，如果结果为原始值，则返回 如果再无可选值，则抛出错误 大多数情况下，标准对象会按照数字模式(Date对象以字符串模式)处理。可通过自定义Symbol.toPrimitive覆盖这些默认的强制转换特性 默认模式只适用于 == + 以及给Date构造函数传递一个参数]]></content>
      <categories>
        <category>《深入理解ES6》--笔记</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ajax 与 跨域请求]]></title>
    <url>%2F2019%2F02%2F21%2FJS%2FXHR%2F</url>
    <content type="text"><![CDATA[XMLKttpRequest对象–Ajax的核心使用 创建 1let xhr = new XMLHttpRequest(); 要调用的第一个方法open()，接收3个参数：要发送的请求的类型、请求的URL以及表示是否异步发送请求的布尔值(非必须) 123let xhr = new XMLHttpRequest();let host = location.href.split('/')[0];xhr.open('get',host+'/message.json',false); URL相对于执行代码的当前页面，也可以是绝对路径，调用open()并不会真正的发送请求，而是启动一个请求以备发送 send()方法：发送特定的请求，接受1个参数，即作为请求主体发送的数据，没有数据发送时需传null 12345let xhr = new XMLHttpRequest();let host = location.href.split('/')[0];xhr.open('get',host+'/message.json',false);xhr.send(null);console.log('data',xhr); 当收到响应之后，相应的数据会自动填充xhr对象的属性 返回的数据： 其中 responseText：作为相应主体被返回的文本 responseXML：如果响应内容是”text/xml”或”application/xml”，这个属性中将包含着响应数据的XML DOM文档 status：响应状态 statusText：响应状态说明 readyState：请求/响应过程的当前活动阶段，这个属性取值如下： 0：未初始化–尚未调用open() 1：启动–已调用open()还未调用send() 2：发送–已调用send()还未收到响应 3：接收–已收到部分响应 4：完成–已接收到全部数据，并且可以在客户端使用 当请求为异步请求时，可以通过检测readyState属性的值来做下一步动作。每次readyState属性值的改变都会触发一次onreadystatechange事件123456789101112131415161718192021222324252627function createElement(&#123;id,data&#125;) &#123; let div = document.getElementById(id); if(typeof data == 'object')&#123; for (const key in data) &#123; let span=document.createElement('span'); span.style.display='block'; span.innerHTML = `&lt;span style="color:#000;font-weight:bold"&gt;$&#123;key&#125;: &lt;/span&gt;$&#123;data[key]&#125;`; div.appendChild(span); &#125; &#125;&#125;let xhr = new XMLHttpRequest();xhr.onreadystatechange = function () &#123; if(xhr.readyState === 4)&#123; if((xhr.status&gt;=200 &amp;&amp; xhr.status&lt;300) || xhr.status == 304)&#123; createElement(&#123; id: 'xhr', data: xhr &#125;) &#125;else&#123; alert('Request was unsuccessful'+xhr.status); &#125; &#125;&#125;let host = location.href.split('/')[0];xhr.open('get', host + '/XHRTest.json', false);xhr.send(null); HTTP头部信息在发送XHR请求的和收到响应时会带有下列头部信息，其中Request Headers为请求头信息，Response Headers为响应头信息Response Headers： Accept: 浏览器能够处理的内容类型 Accept-Charset 浏览器能够显示的字符集 Accept-Encoding: 浏览器能够显示的压缩编码 Accept-Language: 浏览器当前设置的语言 Connection: 浏览器与服务器之间连接的类型 Cookie: 当前页面设置的任何cookie Host: 发送请求的页面所在区域 Referer: 发送请求的页面URL User-Agent: 浏览器的用户代理字符串 setRequestHeader()可以设置自定义请求头部信息，接收2个参数：头部字段的名称和头部字段的值。该方法需要在open()和send()之间调用123xhr.open('get', host + '/XHRTest.json', false);xhr.setRequestHeader('MyHeader', 'MyValue');xhr.send(null); getResponseHeader()方法可以传入头部字段以获取改头部字段名称getAllResponseHeaders()可以获取一个包含所有头部信息的字符串12345678910111213141516171819202122xhr.onreadystatechange = function () &#123; if(xhr.readyState === 4)&#123; if((xhr.status&gt;=200 &amp;&amp; xhr.status&lt;300) || xhr.status == 304)&#123; createElement(&#123; id: 'xhr', data: xhr &#125;); let MyHeader = xhr.getResponseHeader('MyHeader'); createElement(&#123; id: 'myHeader', data: &#123;MyHeader&#125; &#125;); let allHeaders = xhr.getAllResponseHeaders(); createElement(&#123; id: 'allHeaders', data: &#123;allHeaders&#125; &#125;); &#125;else&#123; alert('Request was unsuccessful'+xhr.status); &#125; &#125;&#125; 返回数据 GET和POST请求关于GET和POST请求 可以看看这篇文章HTTP协议中GET和POST方法的区别总结如下： 参数的位置：GET请求的参数通过URL传递，POST通过body传递 缓存：GET可缓存，POST(大部分)不可缓存 安全：对于服务器来说GET比POST安全，因为POST会对资源作出处理，对于传输POST比GET安全，因为GET的参数直接暴露在URL中 GET的长度是受限制：HTTP协议并没有限制URI的长度，具体的长度是由浏览器和系统来约束的(GET请求) GET和POST本质上都是是TCP链接 语义上的区别：GET的语义就是请求获取指定的资源，POST的语义是请求负荷（报文主体）对指定的资源做出处理对于GET产生一个TCP数据包；POST产生两个TCP数据包这句话：对于GET方式的请求，浏览器会把http header和data一并发送出去，服务器响应200（返回数据）； 而对于POST，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok（返回数据）。HTTP 协议中没有明确说明 POST 会产生两个 TCP 数据包，100 continue 只有在请求里带了Expect: 100-continueheader 的时候才有意义。 XMLHttpRequest 2级FormData创建一个FormData对象并向其中添加一些数据1234let data = new FormData();data.append('name','Silvia');// 或者let data = new FormData(document.form[0]); 创建了FormData的实例之后可以将它直接传给send() 超时设定XHR对象有一个timeout属性，表示请求在等待响应多少毫秒之后终止，如果在规定时间内没有响应，则会触发timeout事件进而调用ontimeout()事件处理程序123456xhr.open('get', host + '/XHRTest.json', false);xhr.timeout = 1000;xhr.ontimeout = function()&#123; alert('Request did not return in a second');&#125;xhr.send(null); timeout只能在异步情况下设置，否则会报错：(index):526 Uncaught DOMException: Failed to set the ‘timeout’ property on ‘XMLHttpRequest’: Timeouts cannot be set for synchronous requests made from a document. 跨域详情请看九种跨域方式实现原理（完整版） 同源策略同源指协议+域名+端口必须相同，否则非同源。目的是为了防止浏览器受到XSS、CSFR 等攻击，提高安全性 如果是协议和端口造成的跨域问题“前台”是无能为力的。 在跨域问题上，仅仅是通过“URL 的首部”来识别而不会根据域名对应的 IP 地址是否相同来判断。“URL 的首部”可以理解为“协议, 域名和端口必须匹配” 跨域并不是请求发不出去，请求能发出去，服务端能收到请求并正常返回结果，只是结果被浏览器拦截了 三个标签是允许跨域加载资源：123&lt;img src=XXX&gt;&lt;link href=XXX&gt;&lt;script src=XXX&gt; 跨域解决方案一 JSONP 原理：利用 script 标签没有跨域限制的漏洞，网页可以得到从其他来源动态产生的 JSON 数据。 实现过程：首先需要声明一个请求成功后的回调函数，其参数为请求返回的数据。创建一个script标签，src地址为跨域请求地址?callback=声明的回调函数名。服务器收到请求后，将请求的数据当做回调函数的参数并以字符串形式返回回调函数的调用。eg: res.end(${callback}(&#39;我不爱你&#39;)); 特点：JSONP 都是 GET 和异步请求的，不存在其他的请求方式和同步请求，且 jQuery 默认就会给 JSONP 的请求清除缓存 12345678910111213141516171819202122232425function jsonp(&#123; url, params, callback &#125;) &#123; return new Promise((resolve, reject) =&gt;&#123; let script = document.createElement('script'); window[callback] = function(data) &#123; resolve(data) document.body.removeChild(script); &#125; params = &#123; ...params, callback &#125;; // wd=b&amp;callback=show let arrs = []; for (let key in params) &#123; arrs.push(`$&#123;key&#125;=$&#123;params[key]&#125;`); &#125; script.src = `$&#123;url&#125;?$&#123;arrs.join('&amp;')&#125;` document.body.appendChild(script); &#125;)&#125;jsonp(&#123;url: 'https://blog.silviaxu.com/crossSite.js', params: &#123; wd: 'Iloveyou' &#125;, callback: 'show'&#125;).then((data) =&gt;&#123; console.log(data);&#125;).catch((errror)=&gt;&#123; console.log(errror)&#125;); 请自行将代码拷贝下来运行，结果可打开控制台 跨域解决方案一 corsCORS 需要浏览器和后端同时支持。IE 8 和 9 需要通过 XDomainRequest 来实现。实现 CORS 通信的关键是后端。只要后端实现了 CORS，就实现了跨域。服务端设置 Access-Control-Allow-Origin 就可以开启 CORS。 该属性表示哪些域名可以访问资源，如果设置通配符则表示所有网站都可以访问资源。CORS分为简单请求和复杂请求 简单请求满足条件： 使用下列方法之一：GET/HEAD/POST Content-Type 的值仅限于下列三者之一: application/x-www-form-urlencoded 、multipart/form-data 、text/plain 简单请求流程： 当浏览器发送CORS请求时发现是简单请求，会在请求的头部信息里添加一个Origin(协议+域名+端口)字段，表明请求源，服务器根据这个源判断是否允许这次请求 如果Origin的value在许可范围内，则请求成功，服务器会在响应header里多增加几个字段：Access-Control-Allow-Origin和Access-Control-Allow-Credentials字段 Access-Control-Allow-Credentials：表示是否允许发送cookie。当该属性值为true时，浏览器应该设置xhr.withCredentials = true; 如果Origin的value不在许可范围内，则请求失败,服务器会返回一个正常的HTTP回应。浏览器发现，这个回应的头信息没有包含Access-Control-Allow-Origin字段，从而抛出一个无法跨域的异常（可能是200，所以无法识别） 复杂请求满足条件：使用Put，Delete方法或者Content-Type是application/json复杂请求流程： 在发送CORS请求之前会先发送一个预检请求(OPTIONS请求),服务器也会做出相应的响应，请求成功则进入下一步请求 1234OPTIONS /cors HTTP/1.1Origin: http://localhost:4000Access-Control-Request-Method: PUTAccess-Control-Request-Headers: token // 额外发送的头信息字段 预检请求其实是服务器的一种权限请求，一般缓存下来，以便不需要在每次请求都发送 预检请求通过以后，浏览器发每次出的CORS请求就和简单请求一样，会有一个origin字段，服务器每次回应都会有Access-Control-Allow-Origin头信息字段 一个复杂请求案例12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152// 前端let xhr = new XMLHttpRequest()document.cookie = 'name=xiamen' // cookie不能跨域xhr.withCredentials = true // 前端设置是否带cookiexhr.open('PUT', 'http://localhost:4000/getData', true)xhr.setRequestHeader('name', 'xiamen')xhr.onreadystatechange = function() &#123; if (xhr.readyState === 4) &#123; if ((xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) || xhr.status === 304) &#123; console.log(xhr.response) //得到响应头，后台需设置Access-Control-Expose-Headers console.log(xhr.getResponseHeader('name')) &#125; &#125;&#125;xhr.send()// 后端let express = require('express')let app = express()let whitList = ['http://localhost:3000'] //设置白名单app.use(function(req, res, next) &#123; let origin = req.headers.origin if (whitList.includes(origin)) &#123; // 设置哪个源可以访问我 res.setHeader('Access-Control-Allow-Origin', origin) // 允许携带哪个头访问我 res.setHeader('Access-Control-Allow-Headers', 'name') // 允许哪个方法访问我 res.setHeader('Access-Control-Allow-Methods', 'PUT') // 允许携带cookie res.setHeader('Access-Control-Allow-Credentials', true) // 预检的存活时间 res.setHeader('Access-Control-Max-Age', 6) // 允许返回的头 该项确定 xmlHttpRequest 对象当中 getResponseHeader()方法所能获得的额外信息 res.setHeader('Access-Control-Expose-Headers', 'name') if (req.method === 'OPTIONS') &#123; res.end() // OPTIONS请求不做任何处理 &#125; &#125; next()&#125;)app.put('/getData', function(req, res) &#123; console.log(req.headers) res.setHeader('name', 'jw') //返回一个响应头，后台需设置 res.end('我不爱你')&#125;)app.get('/getData', function(req, res) &#123; console.log(req.headers) res.end('我不爱你')&#125;)app.use(express.static(__dirname))app.listen(4000) 跨域解决方案一 postMessage应用场景： 页面和其打开的新窗口的数据传递 多窗口之间消息传递 页面与嵌套的iframe消息传递 上面三个场景的跨域数据传递 语法：postMessage(message, targetOrigin, [transfer])方法： message: 将要发送到其他 window的数据。 targetOrigin:通过窗口的origin属性来指定哪些窗口能接收到消息事件，其值可以是字符串”*”（表示无限制）或者一个URI。在发送消息的时候，如果目标窗口的协议、主机地址或端口这三者的任意一项不匹配targetOrigin提供的值，那么消息就不会被发送；只有三者完全匹配，消息才会被发送。 transfer(可选)：是一串和message 同时传递的 Transferable 对象. 这些对象的所有权将被转移给消息的接收方，而发送一方将不再保有所有权。 eg:a.html向b.html发送数据并接收返回数据， 123456789101112131415161718// a.html&lt;iframe src="http://localhost:4000/b.html" frameborder="0" id="frame" onload="load()"&gt;&lt;/iframe&gt; //等它加载完触发一个事件//内嵌在http://localhost:3000/a.html&lt;script&gt; function load() &#123; let frame = document.getElementById('frame') frame.contentWindow.postMessage('我爱你', 'http://localhost:4000') //发送数据 window.onmessage = function(e) &#123; //接受返回数据 console.log(e.data) //我不爱你 &#125; &#125;&lt;/script&gt;// b.htmlwindow.onmessage = function(e) &#123; console.log(e.data) //我爱你 e.source.postMessage('我不爱你', e.origin)&#125; 跨域解决方案一 websocketWebsocket是HTML5的一个持久化的协议，它实现了浏览器与服务器的全双工通信，同时也是跨域的一种解决方案。。一般使用 sockit.io 跨域解决方案一 Node中间件代理(两次跨域)同源策略是浏览器需要遵循的标准，而如果是服务器向服务器请求就无需遵循同源策略实现过程： 代理服务器接受客户端请求 。 代理服务器将请求转发给服务器。 代理服务器拿到服务器响应数据。 代理服务器将响应转发给客户端。 跨域解决方案一 nginx反向代理实现原理类似于Node中间件代理，需要搭建一个中转nginx服务器，用于转发请求。使用nginx反向代理实现跨域，是最简单的跨域方式。只需要修改nginx的配置即可解决跨域问题，支持所有浏览器，支持session，不需要修改任何代码，并且不会影响服务器性能原理：通过nginx配置一个代理服务器（域名与domain1相同，端口不同）做跳板机，反向代理访问domain2接口，并且可以顺便修改cookie中domain信息，方便当前域cookie写入，实现跨域登录 跨域解决方案一 window.name + iframe通过iframe的src属性由外域转向本地域，跨域数据即由iframe的window.name从外域传递到本地域。这个就巧妙地绕过了浏览器的跨域访问限制，但同时它又是安全操作。 跨域解决方案一 location.hash + iframea.html欲与c.html跨域相互通信，通过中间页b.html来实现。 三个页面，不同域之间利用iframe的location.hash传值，相同域之间直接js访问来通信。 跨域解决方案一 document.domain + iframe只能用于二级域名相同的情况下，比如 a.test.com 和 b.test.com 适用于该方式。只需要给页面添加 document.domain =&#39;test.com&#39; 表示二级域名都相同就可以实现跨域。实现原理：两个页面都通过js强制设置document.domain为基础主域，就实现了同域。 function createElement({id,data}) { let div = document.getElementById(id); if(typeof data == 'object'){ for (const key in data) { let span=document.createElement('span'); span.style.display='block'; span.innerHTML = `${key}: ${data[key]}`; div.appendChild(span); } }else if(data){ let span=document.createElement('p'); span.innerHTML = `${data}`; div.appendChild(span); } } let xhr = new XMLHttpRequest(); xhr.onreadystatechange = function () { try{ if (xhr.readyState === 4) { if ((xhr.status>=200 && xhr.status]]></content>
      <categories>
        <category>红皮书笔记--《JavaScript高级程序设计》</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>跨域</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React井字棋游戏练习]]></title>
    <url>%2F2019%2F02%2F19%2FReacts%2Ftic-tac-toe%2F</url>
    <content type="text"><![CDATA[React入门教程,项目地址：https://github.com/Oldpost/-tic-tac-toe 本教程内容在完成官网入门教程之后，可以通过学习过程中自己实现一些扩展 以 “(1, 3)” 坐标的方式记录每一步，而不是格子序号 “6”。 在棋步记录列表里加粗显示当前选中的项目。 在 Board 组件中用两个循环渲染出 9 个 Square 格子组件。 添加一个切换按钮来升序或降序显示棋步记录列表。 当一方获胜时，高亮显示连成一线的3颗棋子。 添加开始/暂停按钮，未开始时不可点击 添加时间显示，以及全程所需要的时间 以 “(1, 3)” 坐标的方式记录每一步，而不是格子序号 “6”通过该功能我们可以了解，需要更改的只是将历史记录已坐标的形式展示，而不是以格子序号的形式。结合Board组件中的renderSquare，每次点击Square都会返回当前点击格子的value，将每次点击的value存进历史记录中，并通过value计算出坐标。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475class Game extends React.Component &#123; constructor(props) &#123; super(props); this.state = &#123; history: [&#123; squares: Array(9).fill(null), currentI:null &#125;], stepNumber: 0, xIsNext: true, &#125;; &#125; handleClick(i) &#123; const history = this.state.history.slice(0, this.state.stepNumber + 1); const current = history[history.length - 1]; const squares = current.squares.slice(); if (calculateWinner(squares) || squares[i]) &#123; return; &#125; squares[i] = this.state.xIsNext ? 'X' : 'O'; // 不可以直接修改this.state.squares的值 this.setState(&#123; // squares: squares, // 直接使用this.state.squares时点击状态没有改变 history: history.concat([&#123; squares: squares, currentI:i &#125;]), stepNumber:history.length, xIsNext: !this.state.xIsNext, &#125;); &#125; jumpTo(step) &#123; this.setState(&#123; stepNumber: step, xIsNext: (step % 2) ? false : true, &#125;); &#125; render() &#123; const history = this.state.history; const current = history[this.state.stepNumber]; const winner = calculateWinner(current.squares); const moves = history.map((step, move) =&gt; &#123; let currentI = step.currentI; const desc =typeof currentI === 'number'? 'Move #' + parseInt(currentI/3 + 1)+','+(currentI%3+1) : 'Game start'; return ( &lt;li key=&#123;move&#125;&gt; &lt;a href="#" onClick=&#123;() =&gt; this.jumpTo(move)&#125;&gt;&#123;desc&#125;&lt;/a&gt; &lt;/li&gt; ); &#125;); let status; if (winner) &#123; status = 'Winner: ' + winner; &#125; else &#123; status = 'Next player: ' + (this.state.xIsNext ? 'X' : 'O'); &#125; return ( &lt;div className="game"&gt; &lt;Errors /&gt; &lt;div className="game-board"&gt; &lt;Board squares=&#123;current.squares&#125; onClick=&#123;(i) =&gt; this.handleClick(i)&#125;/&gt; &lt;/div&gt; &lt;div className="game-info"&gt; &lt;div&gt;&#123;status&#125;&lt;/div&gt; &lt;ol&gt;&#123;moves&#125;&lt;/ol&gt; &lt;/div&gt; &lt;/div&gt; ); &#125;&#125; 在棋步记录列表里加粗显示当前选中的项目由于对需求理解错误导致多实现了一个功能：在井字棋中加粗显示当前选中的格子 在井字棋中加粗显示当前选中的格子首先去掉css文件中.square的font-weight: bold;属性，并新增一个class123456789101112131415.square &#123; background: #fff; border: 1px solid #999; float: left; font-size: 24px; /* font-weight: bold; */ line-height: 34px; height: 34px; margin-right: -1px; margin-top: -1px; padding: 0; text-align: center; width: 34px;&#125;.active&#123;font-weight: bold;&#125; 在Game组件中由于存储了this.state.currentI即当前棋子的value值，将其传递给Board组件并判断当前渲染的格子是否是选中的格子1234567renderSquare(i) &#123; return &lt;Square isCurrent=&#123;this.props.currentNum === i?' active':''&#125; value=&#123;this.props.squares[i]&#125; onClick=&#123;() =&gt; this.props.onClick(i)&#125; // JSX 元素的最外层套上了一小括号，以防止 JavaScript 代码在解析时自动在换行处添加分号 /&gt;;&#125; Square组件添加className1234567function Square(props) &#123; return ( &lt;button className=&#123;"square"+ props.isCurrent&#125; onClick=&#123;props.onClick&#125;&gt; &#123;props.value&#125; &lt;/button&gt; );&#125; 在棋步记录列表里加粗显示当前选中的项目利用棋步记录列表的key值move和当前的stepNumber进行比较，相等则证明是当前选中的项目1234567891011const moves = history.map((step, move) =&gt; &#123; let currentI = step.currentI; const desc =typeof currentI === 'number'? 'Move #' + parseInt(currentI/3 + 1)+','+(currentI%3+1) : 'Game start'; return ( &lt;li key=&#123;move&#125;&gt; &lt;a href="#" className=&#123;move===this.state.stepNumber?'active':''&#125; onClick=&#123;() =&gt; this.jumpTo(move,currentI)&#125;&gt;&#123;desc&#125;&lt;/a&gt; &lt;/li&gt; );&#125;); 添加一个切换按钮来升序或降序显示棋步记录列表添加一个Btn组件，显示升序或者降序1234567function Btn(props) &#123; return ( &lt;button onClick=&#123;props.onClickUp&#125;&gt; &#123;props.historyStatus?'降序':'升序'&#125; &lt;/button&gt; );&#125; Game组件constructor中增加历史记录展示状态historyStatus 12345678910111213constructor(props) &#123; super(props); this.state = &#123; history: [&#123; squares: Array(9).fill(null), currentI:null &#125;], stepNumber: 0, currentI:null, xIsNext: true, historyStatus:true, &#125;;&#125; 添加renderBtn函数123456renderBtn() &#123; return &lt;Btn historyStatus=&#123;this.state.historyStatus&#125; onClickUp=&#123;() =&gt; this.onClickUp()&#125; /&gt;;&#125; 在render中进行渲染1234567891011121314151617return ( &lt;div className="game"&gt; &lt;Errors /&gt; &lt;div className="game-board"&gt; &lt;Board currentNum=&#123;currentNum&#125; squares=&#123;current.squares&#125; onClick=&#123;(i) =&gt; this.handleClick(i)&#125;/&gt; &lt;/div&gt; &lt;div className="game-info"&gt; &#123;this.renderBtn()&#125; &lt;div&gt;&#123;status&#125;&lt;/div&gt; &lt;ol&gt;&#123;this.state.historyStatus?moves:moves.reverse()&#125;&lt;/ol&gt; &lt;/div&gt; &lt;/div&gt;); 到这里按钮已经能够被完美的渲染出来，但是点击没效果，我们需要添加点击时的交互12345onClickUp()&#123; this.setState(&#123; historyStatus: !this.state.historyStatus, &#125;);&#125; 当一方获胜时，高亮显示连成一线的3颗棋子首先在五子棋算法中修改返回值，将当前获胜的连成一线的3颗棋子的value返回123456789for (let i = 0; i &lt; lines.length; i++) &#123; const [a, b, c] = lines[i]; if (squares[a] &amp;&amp; squares[a] === squares[b] &amp;&amp; squares[a] === squares[c]) &#123; return &#123; winner:squares[a], line:[a, b, c] &#125;; &#125;&#125; Game组件中修改render函数，因为此时calculateWinner()返回值是对象,status展示的内容改变为：**、currentNum传递数组、Board数组直接将currentNum传递给currentNum123456789101112131415161718192021222324252627282930313233343536373839404142render() &#123; const history =this.state.history; const current = history[this.state.stepNumber]; const winner = calculateWinner(current.squares); const currentNum = winner?winner.line:Array(1).fill(this.state.currentI); const moves = history.map((step, move) =&gt; &#123; let currentI = step.currentI; const desc =typeof currentI === 'number'? 'Move #' + parseInt(currentI/3 + 1)+','+(currentI%3+1) : 'Game start'; return ( &lt;li key=&#123;move&#125;&gt; &lt;a href="#" className=&#123;move===this.state.stepNumber?'active':''&#125; onClick=&#123;() =&gt; this.jumpTo(move,currentI)&#125;&gt;&#123;desc&#125;&lt;/a&gt; &lt;/li&gt; ); &#125;); let status; if (winner) &#123; status = 'Winner: ' + winner.winner; &#125; else &#123; status = 'Next player: ' + (this.state.xIsNext ? 'X' : 'O'); &#125; return ( &lt;div className="game"&gt; &lt;Errors /&gt; &lt;div className="game-board"&gt; &lt;Board currentNum=&#123;currentNum&#125; squares=&#123;current.squares&#125; onClick=&#123;(i) =&gt; this.handleClick(i)&#125;/&gt; &lt;/div&gt; &lt;div className="game-info"&gt; &#123;this.renderBtn()&#125; &lt;div&gt;&#123;status&#125;&lt;/div&gt; &lt;ol&gt;&#123;this.state.historyStatus?moves:moves.reverse()&#125;&lt;/ol&gt; &lt;/div&gt; &lt;/div&gt; );&#125; 最后renderSquare修改为1234567891011renderSquare(i) &#123; const currentNum =this.props.currentNum const isCurrent = currentNum.some(function (value,index,arr) &#123; return value === i &#125;); return &lt;Square isCurrent=&#123; isCurrent?' active':''&#125; value=&#123;this.props.squares[i]&#125; onClick=&#123;() =&gt; this.props.onClick(i)&#125; // JSX 元素的最外层套上了一小括号，以防止 JavaScript 代码在解析时自动在换行处添加分号 /&gt;;&#125; 添加开始/暂停按钮，未开始时不可点击开始按钮组件，需要一个点击回调事件、记录是否开始状态和游戏结束时不可点击状态1234567function StartAndPauseBtn(props) &#123; return ( &lt;button onClick=&#123;props.onClickStartAndPause&#125; className="btn" disabled=&#123;props.isEnd&#125;&gt; &#123;props.isStart ? 'Click to pause' : 'Click to start'&#125; &lt;/button&gt; );&#125; Game组件中新增isStart状态记录当前是否开启，并实现渲染开始组件123456789101112131415161718192021constructor(props) &#123; super(props); this.state = &#123; history: [&#123; squares: Array(9).fill(null), currentI:null &#125;], stepNumber: 0, currentI:null, xIsNext: true, historyStatus:true, isStart:false, &#125;;&#125;renderStartAndPauseBtn(winner) &#123; return &lt;StartAndPauseBtn isEnd=&#123;winner?true:false&#125; isStart=&#123;this.state.isStart&#125; onClickStartAndPause=&#123;() =&gt; this.onClickStartAndPause()&#125; // JSX 元素的最外层套上了一小括号，以防止 JavaScript 代码在解析时自动在换行处添加分号 /&gt;;&#125; Game组件的render函数中渲染组件123456&lt;div className="game-info"&gt; &#123;this.renderBtn()&#125; &#123;this.renderStartAndPauseBtn(winner)&#125; &lt;div&gt;&#123;status&#125;&lt;/div&gt; &lt;ol&gt;&#123;this.state.historyStatus?moves:moves.reverse()&#125;&lt;/ol&gt;&lt;/div&gt; 到这里已经实现了按钮的渲染，接下来实现点击开始/暂停，没有开始不可点击123456789101112131415onClickStartAndPause()&#123; this.setState(&#123; isStart: !this.state.isStart, &#125;);&#125;handleClick(i) &#123; const history = this.state.history.slice(0, this.state.stepNumber + 1); const current = history[history.length - 1]; const squares = current.squares.slice(); const isStart = this.state.isStart; if (!isStart)&#123; return; &#125; ...&#125; 添加时间显示，以及全程所需要的时间这个需求源于react文档中的一个计时器，通过对计时器的改造可以实现在当前页面上渲染时间，并通过开始/暂停按钮的点击以及获胜计算这场游戏总共花费的时间1234567891011// 计时器function tick() &#123; const element = ( &lt;div&gt; &lt;h1&gt;Hello, world!&lt;/h1&gt; &lt;h2&gt;It is &#123;new Date().toLocaleTimeString()&#125;.&lt;/h2&gt; &lt;/div&gt; ); ReactDOM.render(element, document.getElementById('root'));&#125;setInterval(tick, 1000); 时钟Game组件的constructor中新增currentTime记录现在的时刻，render函数中新增一个定时器，没1000ms更新一次currentTime状态123456789101112131415161718192021constructor(props) &#123; super(props); this.state = &#123; history: [&#123; squares: Array(9).fill(null), currentI:null &#125;], stepNumber: 0, currentI:null, xIsNext: true, historyStatus:true, isStart:false, currentTime: new Date().toLocaleTimeString() &#125;;&#125;// render函数中const setTimes = setInterval(() =&gt; &#123; this.setState(&#123; currentTime: new Date().toLocaleTimeString() &#125;);&#125;, 1000); 接下来将日期显示在页面中1234567891011121314renderCurrentTime() &#123; return &lt;div&gt; &lt;span&gt;Hi old man!&lt;/span&gt; &lt;span&gt; It is now &#123;this.state.currentTime&#125;.&lt;/span&gt; &lt;/div&gt;&#125;// render函数中&lt;div className="game-info"&gt; &#123;this.renderCurrentTime()&#125; &#123;this.renderBtn()&#125; &#123;this.renderStartAndPauseBtn(winner)&#125; &lt;div&gt;&#123;status&#125;&lt;/div&gt; &lt;ol&gt;&#123;this.state.historyStatus?moves:moves.reverse()&#125;&lt;/ol&gt;&lt;/div&gt; 优化时钟通过类组件的生命周期钩子实现时钟。在组件挂载时添加定时器，在组件卸载时清除定时器1234567891011tick() &#123; this.setState(&#123; currentTime: new Date().toLocaleTimeString() &#125;);&#125;componentDidMount() &#123; this.setTimes = setInterval(() =&gt; this.tick(), 1000);&#125;componentWillUnmount() &#123; clearInterval(this.setTimes);&#125; 最后删除render函数中的定时器 计算这场游戏总共花费的时间花费的时间=结束时间-开始时间-暂停花费的时间。Game组件的constructor中新增startTime和alltimes分别记录开始时间和总共花费的时间1234567891011121314151617constructor(props) &#123; super(props); this.state = &#123; history: [&#123; squares: Array(9).fill(null), currentI:null &#125;], stepNumber: 0, currentI:null, xIsNext: true, historyStatus:true, isStart:false, startTime: 0, alltimes:0, currentTime:new Date().toLocaleTimeString() &#125;;&#125; 修改onClickStartAndPause(),当前状态为未开始时，存储开始时间并修改isStart状态为true。当前状态为已开始时，存储游戏总共花费了多少时间123456789101112131415onClickStartAndPause()&#123; const currentTime = new Date().getTime(); const startTime = this.state.startTime ? this.state.startTime:new Date().getTime(); if (this.state.isStart)&#123; this.setState(&#123; alltimes:this.state.alltimes + currentTime - startTime, isStart: !this.state.isStart, &#125;); &#125;else&#123; this.setState(&#123; isStart: !this.state.isStart, startTime: currentTime &#125;); &#125; &#125; 修改handleClick()，新增每次点击格子时都记录当前总共花费的时间。因为可能中途没有暂停1234567891011121314151617181920212223242526handleClick(i) &#123; const history = this.state.history.slice(0, this.state.stepNumber + 1); const current = history[history.length - 1]; const squares = current.squares.slice(); const isStart = this.state.isStart; const currentTime=new Date().getTime() if (!isStart)&#123; return; &#125; if (calculateWinner(squares) || squares[i]) &#123; return; &#125; squares[i] = this.state.xIsNext ? 'X' : 'O'; // 不可以直接修改this.state.squares的值 this.setState((prevState) =&gt; (&#123; // squares: squares, // 直接使用this.state.squares时点击状态没有改变 history: history.concat([&#123; squares: squares, currentI:i &#125;]), alltimes: prevState.alltimes + currentTime - prevState.startTime, startTime: currentTime, stepNumber:history.length, xIsNext: !prevState.xIsNext, currentI:i &#125;));&#125; 最后实现渲染1234567891011121314151617renderAllTimes() &#123; if(winner)&#123; return &lt;div&gt; &lt;span&gt; It lasts &#123;this.state.alltimes&#125;ms&lt;/span&gt; &lt;/div&gt; &#125; return null&#125;// render()中&lt;div className="game-info"&gt; &#123;this.renderCurrentTime()&#125; &#123;this.renderBtn()&#125; &#123;this.renderStartAndPauseBtn(winner)&#125; &#123;winner ? this.renderAllTimes():''&#125; &lt;div&gt;&#123;status&#125;&lt;/div&gt; &lt;ol&gt;&#123;this.state.historyStatus?moves:moves.reverse()&#125;&lt;/ol&gt;&lt;/div&gt;]]></content>
      <categories>
        <category>React学习</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[解构：使数据访问更便捷]]></title>
    <url>%2F2019%2F01%2F29%2FES6%2Fdeconstruction%2F</url>
    <content type="text"><![CDATA[英文原版：Understanding ECMAScript 6 为何使用解构？123456let options = &#123; repeat:true, save:false&#125;;let repeat = options.repeat, save = options.save; 使用场景为要将对象的属性值提取出来单独存储，当要提取更多的变量时，或者还嵌套着多层结构时提取变量会变得很繁琐。为此，ES6为数组和对象都添加了解构功能，将数据结构打散。 对象解构如果使用var、let或const解构声明变量，则必须提供初始化程序，否则报语法错误1234567let node = &#123; type:'Identifier', name:'foo'&#125;let &#123;type, name&#125; = node;console.log(type) // Identifierconsole.log(name) // foo 此时的type和name是局部声明的变量 解构赋值可以在定义变量之后想要修改它们的值：123456789let node = &#123; type: 'Identifier', name: 'foo'&#125;,type = 'Literal',name = 5;(&#123;type,name&#125; = node);console.log(type) // Identifierconsole.log(name) // foo 代码中由于已经对type、name定义及初始化，不能在使用 let {type, name} = node的形式修改其值。JavaScript中定义{}为代码块，代码块是不允许出现在赋值语句的左侧的，添加花括号之后将块语句转化为一个表达式，从而可以实现解构过程。函数调用中传入解构表达式：12345678910111213let node = &#123; type: 'Identifier', name: 'foo'&#125;,type = 'Literal',name = 5;function outputInfo(value) &#123; console.log(value) console.log( value === node ) // true&#125;outputInfo(&#123;type,name&#125; = node);console.log(type) // Identifierconsole.log(name) // foo 调用outputInfo()时传入解构表达式，由于JavaScript表达式的值为右侧的值，因而此处传入的参数等同于node，且变量type、name被重新赋值。 解构赋值表达式如果传入(即=右侧的表达式)如果为null或undefined会导致程序抛出错误 默认值如果指定的局部变量名称在对象中不存在，那么会被赋值为undefined，可以为其定义一个默认值：123456789let node = &#123; type: 'Identifier', name: 'foo'&#125;;let &#123;type,name,value,age = 18&#125; = node;console.log(type) // Identifierconsole.log(name) // fooconsole.log(value) // undefinedconsole.log(age) // 18 为非同名局部变量赋值提取对象中的属性并保存在不同的变量名中:1234567let node = &#123; type: 'Identifier', name: 'foo'&#125;;let &#123;type:localType,name:localName&#125; = node;console.log(localType) // Identifierconsole.log(localName) // foo 同时为非同名局部变量赋值并设置默认值：123456let node = &#123; type: 'Identifier'&#125;;let &#123;type:localType,name:localName = 'bar'&#125; = node;console.log(localType) // Identifierconsole.log(localName) // bar 嵌套对象解构1234567891011121314151617181920let node = &#123; type: 'Identifier', name:'foo', loc:&#123; start:&#123; line:1, column:1 &#125;, end:&#123; line: 1, column: 4 &#125; &#125;&#125;;let &#123;loc:&#123;start&#125;&#125; = node;console.log(start.column) // 1console.log(start.line) // 1let &#123;loc:&#123;start:&#123;line:localline&#125;&#125;&#125; = node;console.log(localline) // 1 {loc:{start}}找到node对象中的loc属性后，深入一层继续查找start属性。loc表示在对象中检索属性的位置 数组解构123456let colors = ['green','red','blue'];let [firstColor,secondColor] = colors;let [,,thirdColor] = colors;console.log(firstColor) // greenconsole.log(secondColor) // redconsole.log(thirdColor) // blue [,,thirdColor]语句中thirdColor前的两个逗号表示前方元素的占位符 解构赋值1234let a = 1,b = 2;[a,b] = [b,a]console.log(a); // 2console.log(b); // 1 默认值1234let colors = ['green'];[firstColor,secondColor = 'red'] = colors;console.log(firstColor) // greenconsole.log(secondColor) // red 嵌套数组解构1234let colors = ['green', ['red', 'black'], 'blue'];let [firstColor, [,secondColor]] = colors;console.log(firstColor) // greenconsole.log(secondColor) // black 不定元素1234567let colors = ['green', 'red', 'black', 'blue'];let [firstColor, ...restColor] = colors;console.log(firstColor) // greenconsole.log(restColor.length) // 3console.log(restColor[0]); // redconsole.log(restColor[1]); // blackconsole.log(restColor[2]); // blue 使用不定元素克隆数组123let colors = ['green', 'red', 'black', 'blue'];let [...restColor] = colors;console.log(restColor) // ["green", "red", "black", "blue"] 混合解构12345678910111213141516171819let node = &#123; type: 'Identifier', name:'foo', loc:&#123; start:&#123; line:1, column:1 &#125;, end:&#123; line: 1, column: 4 &#125; &#125;, colors: ['green', 'red']&#125;;let &#123;loc:&#123;start&#125;,colors:[firstColor]&#125; = node;console.log(start.column) // 1console.log(start.line) // 1console.log(firstColor) // green 解构参数12345678910111213141516function setCookie(name,value,options) &#123; let secure = options.secure, path = options.path, domain = options.domain, expires = options.expires; return &#123;secure, path, domain, expires&#125;&#125;// 或// function setCookie(name,value,&#123;secure, path, domain, expires&#125;) &#123;// return &#123;secure, path, domain, expires&#125;// &#125;let cookie = setCookie('type','js',&#123; secure:true, expires:6000&#125;);console.log(cookie); // &#123;secure: true, path: undefined, domain: undefined, expires: 6000&#125; 必须传值的解构参数解构参数如果在调用时没有传入参数则会报错，原因是不传入参数那么默认的该参数会赋值为undefined，解构赋值表达式的右值为undefined或null时程序报错。可用默认值解决这个问题1234567function setCookie(name,value,&#123;secure, path, domain, expires&#125; = &#123;&#125;) &#123; return &#123;secure, path, domain, expires&#125;&#125;// 或function setCookie(name,value,&#123;secure = false, path = '/', domain = 'example.com', expires = new Date(Date.now()+360000000)&#125; = &#123;&#125;) &#123; return &#123;secure, path, domain, expires&#125;&#125;]]></content>
      <categories>
        <category>《深入理解ES6》--笔记</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[扩展对象的功能性]]></title>
    <url>%2F2019%2F01%2F29%2FES6%2FES6-4%2F</url>
    <content type="text"><![CDATA[英文原版：Understanding ECMAScript 6 对象类别 普通对象(Ordinary)：具有JavaScript对象所有的默认内部行为 特异对象(Exotic)：具有某些与默认行为不符的内部行为 标准对象(Standard)：ECMAScript 6规范中定义的对象，eg: Array/Date。标准对象既可以是普通对象，也可以是特异对象 内建对象：脚本开始执行时存在于JavaScript执行环境中的对象，所有的标准对象都是内建对象 对象字面量语法扩展属性初始值的简写ECMAScript5中对象字面量只是简单的键值对集合–意味着初始化属性值会有一些重复。123456function createPerson(name,age) &#123; return &#123; name:name, age:age &#125;&#125; ES6中当一个对象的属性与本地变量名同名时，不必再写冒号和值，只简单地写属性名即可123456function createPerson(name,age) &#123; return &#123; name, age &#125;&#125; 对象的简写语法ES5中给对象添加方法必须通过指定名称并完整定义函数来实现，ES6消除了冒号和function关键字，并且可以使用super关键字1234567// sayName属性被赋值为一个匿名函数表达式let person = &#123; name:'Silvia', sayName()&#123; consoel.log(this.name) &#125;&#125; 通过对象方法简写创建的方法后一个name属性 可计算属性名12345678let key = ' name';let person = &#123; ['person'+key]:'Silvia', sayName()&#123; consoel.log(this['person name']); &#125;&#125;console.log(person['person'+key]) // Silvia 新增方法Object.is()为了弥补全等运算符(===)的不准确运算，eg：NaN === NaN 返回false 或 -0 === +0 返回true。ES6提出Object.is()：接受两个参数，如果这两个参数类型相同并具有相同的值，则返回true1234567console.log(-0 == +0); // trueconsole.log(-0 === +0); //trueconsole.log(Object.is(-0,+0)); // false -0和+0表示两个完全不同的实体console.log(NaN == NaN); // falseconsole.log(NaN === NaN); //falseconsole.log(Object.is(NaN,NaN)); // true Object.assign()该方法实现功能：12345678910111213141516171819function mixin(receiver,supplier) &#123; Object.keys(supplier).forEach(function(key) &#123; receiver[key] = supplier[key]; // 被认为是浅复制--当supplier[key]为对象时 &#125;) return receiver;&#125;function EventTarget() &#123;&#125;EventTarget.prototype = &#123; constructor:EventTarget, emit:function()&#123; // 发布 &#125;, on:function()&#123; // 订阅 &#125;&#125;var myObj = &#123;&#125;mixin(myObj,EventTarget.prototype);myObj.emit('somethingChanged'); 在第三方库中可能被定义成了其他方法名，eg:extend()和mix() 该方法接受一个接收对象和任意数量的源对象，通过赋值操作符来复制源对象的相关属性并按顺序添加到接收对象中，但是不能复制源对象的访问器属性(get属性和set属性)到接收对象中。如果对个源对象具有相同属性名，那么后面的会覆盖前面的。123456789101112// 访问器属性let receiver = &#123;&#125;;let supplier = &#123; get name()&#123; return 'Silvia' &#125;&#125;Object.assign(receiver,supplier);var descriptor = Object.getOwnPropertyDescriptor(receiver,'name');console.log('descriptor',descriptor)console.log(descriptor.value);console.log(descriptor.get) 重复的对象字面量属性在严格模式下，ES5中有一个重复属性检验的检测，第二个重复属性会报语法错误。但是在ES6中移除了这个校验，对一组重复的属性，都会取最后一个取值 自有属性枚举顺序ES5中未定义属性枚举顺序，但是在ES6中规定了对象的自有属性被枚举时返回的顺序。这影响到了Object.getOwnPropertyNames()，Reflect.ownKeys()和Object.assign()返回属性的方式。其枚举基本规则： 所有数字键按升序排序 所有字符串键按照它们被加入对象的顺序排序。 所有symbol键按照它们被加入到对象的顺序排序 12345678910let obj = &#123; a:1, 0:1, c:1, 2:1, b:1, 1:1&#125;obj.d = 1;console.log(Object.getOwnPropertyNames(obj).join('')); // 012acbd for-in循环，仍未指定明确的枚举顺序，Object.keys()和JSON.stringify()方法都指明与for-in的枚举顺序一致。 增强对象原型改变对象的原型正常情况下，无论是通过构造函数还是Object.create()方法创建对象，其原型都是在对对象被创建时指定。对象原型在实例化之后保持不变。ES5中没有在实例化之后改变原型的方法，只有Object.getPrototype()方法来获取实例的原型。ES6中增加了Object.setPrototypeOf()来改变原型。接收两个参数：被改变原型的对象、替代第一个参数原型的对象对象原型的真实值储存在内部专用属性[[Prototype]]中，Object.getPrototype()返回改储存的值，Object.setPrototypeOf()改变其值。 简化原型访问的Super引用如果想重写对象实例的方法，有需要调用与它同名的原型方法。可以这样做：123456789101112131415161718192021222324252627let cat = &#123; name:'cat', getGreeting()&#123; return 'Hello'; &#125;&#125;let dog = &#123; name: 'dog', getGreeting()&#123; return 'Woof'; &#125;&#125;let friend = &#123; name: 'friend', getGreeting()&#123; console.log(this); console.log(Object.getPrototypeOf(this)); return Object.getPrototypeOf(this).getGreeting.call(this)+",hi！"; // call(this)确保多重继承时的this值永远指向friend &#125;&#125;Object.setPrototypeOf(friend,cat);console.log(friend.getGreeting());console.log(Object.getPrototypeOf(friend) === cat);Object.setPrototypeOf(friend,dog);console.log(friend.getGreeting());console.log(Object.getPrototypeOf(friend) === dog); 以上代码比较复杂，ES6中引入Super关键字，Super引用相当于指向对象原型的指针实际上也就是Object.getPrototypeOf(this)的值，于是，代码可简化为：1234567let friend = &#123; name: 'friend', getGreeting() &#123; // return Object.getPrototypeOf(this).getGreeting.call(this) + ",hi！"; return super.getGreeting()+",hi！" &#125;&#125; Super引用只能在简写方法的对象中使用，否则报语法错误。 在多重继承的情况下，return Object.getPrototypeOf(this).getGreeting.call(this)+”,hi！”;会出现递归调用导致栈溢出。因为this始终是friend，那么它的Object.getPrototypeOf(this)永远是friend的原型，从而进入递归直至栈溢出。123456789101112131415161718let cat = &#123; name:'cat', getGreeting()&#123; return 'Hello'; &#125;&#125;let friend2 = &#123; name: 'friend2', getGreeting() &#123; console.log(this); console.log(super.getGreeting()); // return Object.getPrototypeOf(this).getGreeting.call(this) + ",hi！"; return super.getGreeting() + ",hi！" &#125;&#125;Object.setPrototypeOf(friend2, cat);let relative = Object.create(friend2);console.log(relative.getGreeting()); 正式的方法定义ES6中正式将方法定义为一个函数，它将有一个内部的[[HomeObject]]属性来容纳这个方法从属的对象。12345678910let person = &#123; // 是方法 getGreeting()&#123; return 'hello' &#125;&#125;// 不是方法function shareGreeting() &#123; return 'hi'&#125; Super的引用123456789101112let person2 = &#123; getGreeting()&#123; return 'hello'; &#125;&#125;;let friend = &#123; getGreeting()&#123; return super.getGreeting()+",hi"; &#125;&#125;;Object.setPrototypeOf(friend,person2);console.log(friend.getGreeting()) // hello,hi 调用friend.getGreeting()会将person2.getGreeting()的返回值与’,hi’拼接成新的字符串返回。friend.getGreeting()方法的[[HomeObject]]属性值是friend,friend的原型式person2,所以super.getGreeting()等价于person2.getGreeting().call(this)]]></content>
      <categories>
        <category>《深入理解ES6》--笔记</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[引用类型]]></title>
    <url>%2F2019%2F01%2F28%2FJS%2FJS5%2F</url>
    <content type="text"><![CDATA[对象是某个特定引用类型的实例 Object 类型创建 Object构造函数：new Object() 对象字面量：var obj = {} 对象字面量创建的数值属性名会自动转换为字符串 123456var person = &#123; 'name':'Silvia', 5:true &#125;;console.log(person[5]); //trueconsole.log(person['5']); //true 检测instanceof 操作符检测属性1console.log(person instanceof Object); // true 访问对象属性 点表示法 方括号 ，方括号方法可以访问数值属性以及可以通过变量来访问属性值 Array 类型数组的每一项可以保存任何类型的数据 创建 Array构造函数：new Array() 创建的时候可省略new操作符 对象字面量：var arr = [] 123456789101112var arr = Array(3);console.log(arr) // [empty × 3]console.log(arr.length) // 3var arr0 = Array(3,1);console.log(arr0) // [3, 1]console.log(arr0.length) // 2var arr1 = [3];console.log(arr) // [empty × 3]console.log(arr.length) // 3var arr2 = [3,1];console.log(arr2) // [3, 1]console.log(arr2.length) // 2 检测instanceof 操作符检测属性 或者调用isArray()，是则返回true否则为false123console.log(arr instanceof Array); // trueconsole.log(arr instanceof Object); // trueconsole.log(Array.isArray(arr)) // true 数组既是Array的实例也是Object的实例 length属性数组的length可读/写数组长度123456var arr = [1,2,3,4,5,6];console.log(arr) // [1, 2, 3, 4, 5, 6];arr.length = 4;console.log(arr.5) // [1, 2, 3, 4];arr.length = 9;console.log(arr) // [1, 2, 3, 4, 5, 6, empty × 3]; 转换方法 toLocaleString()：返回由数组中每个值的字符串形式拼接而成的以一个逗号分隔的字符串。创建该字符串会调用每项的toLocaleString()方法 toString()：返回由数组中每个值的字符串形式拼接而成的以一个逗号分隔的字符串。创建该字符串会调用每项的toString()方法 valueOf()：返回数组本身 join()：可以使用不同的分隔符(接收的参数)来构建这个字符串 1234567var arr = [1,2,3,4];console.log(arr.valueOf()); // [1, 2, 3, 4] 返回数组本身console.log(arr.toString()); // 1,2,3,4console.log(typeof arr.toString()); // stringconsole.log(arr.toLocaleString()); // 1,2,3,4console.log(typeof arr.toLocaleString()) // stringconsole.log(arr.join('=')); // 1=2=3=4 栈方法和列队方法栈是一种LIFO(Last In First Out)的数据结构，栈中项的插入(推入)和移除(弹出)只发生在栈的顶部。 push()：接受任意数量的参数，按顺序逐个添加到栈尾，并返回修改后的数组的长度 pop()：移除数组末尾的最后一项，length-1，并返回移除的项 列队数据结构的访问规则是FIFO(First In First Out)，列队在列表的末端添加项，在前端移除项。 unshift()：在数组前端添加任意个项，并返回数组长度 shift()：移除前端第一项,length-1,并返回移除的项 123456789// 原来的arr：1,2,3,4arr.push(5,6,7);console.log(arr); // [1, 2, 3, 4, 5, 6, 7]arr.pop();console.log(arr); // [1, 2, 3, 4, 5, 6]arr.unshift(5, 6, 7);console.log(arr); // [5, 6, 7, 1, 2, 3, 4, 5, 6]arr.shift();console.log(arr); // [6, 7, 1, 2, 3, 4, 5, 6] 重排序 reverse()：反转数组项 sort()：默认按升序排列数组项。调用每个数组的toString转型得到字符串，所以sort()默认比较的是字符串编码大小。sort()可以接收一个比较函数作为参数，以便于指定哪个值位于哪个值前面。比较函数接收两个参数，第一个比第二个大则返回负数，第二个比第一个大则返回正数，相等则返回01234567891011121314151617181920212223function compareDown(value1,value2) &#123; // 相当于 return value2 - value1 if(value1 &gt; value2)&#123; return -1 &#125; else if (value1 &lt; value2) &#123; return 1 &#125;else&#123; return 0 &#125;&#125;function compareUp(value1, value2) &#123; // 相当于 return value1 - value2 if (value1 &gt; value2) &#123; return 1 &#125; else if (value1 &lt; value2) &#123; return -1 &#125; else &#123; return 0 &#125;&#125;var arr = [1,6,10,5,7,12];console.log(arr.sort(compareDown)) // [12, 10, 7, 6, 5, 1]console.log(arr.sort(compareUp)) // [1, 5, 6, 7, 10, 12] 操作方法 concat()：先创建当前数组的一个副本，然后将接收到的参数按顺序添加到这个副本的尾部，最后返回新创建的数组，没有参数则返回这个副本。如果传给concat()方法的是一或多个数组，则该方法会将数组中的每一项都添加到结果数组中。如果不是则只是简单的添加到结果数组的末尾。 slice()：语法为arr.slice(startIndex[,endIndex]) 传入2个参数时复制并返回从startIndex到(endIndex-1)的项组成的新数组，否则复制并返回从startIndex到末尾的新数组。如果传入的参数有负数，则用数组长度加上该数来确定相应的位置 splice()：直接影响到原数组！使用方式如下三种： 删除：可以删除任意数量的项，只需传入两个参数，要删除的第一项的位置和要删除的项数 插入：向指定位置插入任意数量的项，需传入三个或以上参数，起始位置、0(要删除的项数)和要插入的项 替换：向指定位置插入任意数量的项，且同时可以删除任意数量的项，需传入三个或以上参数，起始位置、要删除的项数和要插入的项 1234var arr=['a','b','c','d','e'];var removed = arr.splice(2,1); // ["a", "b", "d", "e"]var add = arr.splice(2,0,'f','g'); // ["a", "b", "f", "g", "d", "e"]var replace = arr.splice(2,1,'h','i'); // ["a", "b", "h", "i", "g", "d", "e"] 123456789var a = ['a', 'b', 'c'];var b = [1, 2, 3];var c = a.concat(b, '新加的');var d = c.slice(1,5);var e = c.slice(-6, -2); // 相当于c.slice(7-6, 7-2)console.log(c); // ["a", "b", "c", 1, 2, 3, "新加的"]console.log(c.length); // 7console.log(d); // ["b", "c", 1, 2]console.log(e); // ["b", "c", 1, 2] 位置方法indexOf() 和 lastIndexOf() (查找采用三等号查询’===’)都接受2个参数：要查找的项和(可选的)表示查找起点位置的索引，返回查找的项在数组中的位置，没有则返回-1 迭代方法ES5提供5个迭代方法，都接收两个参数，要在每一项上运行的函数和(可选)运行该函数的作用域对象–影响this值。传入的运行函数可接收三个参数：数组项的值，该项的索引值和数组本身 every()：用于检测数组是否能满足传递函数的条件，数组每项执行callback时，当有返回false时every立即返回false,否则every返回值为true some()：用于检测数组是否能满足传递函数的条件，在数组每项执行callback时，当有返回true时every立即返回true,否则every返回值为false filter()：利用指定函数确定是否在返回的数组中包含某项，即返回过滤后的数组，运行函数返回true则返回数组包含该项。 map()：返回一个处理过后的数组 forEach()：没有返回，与for循环迭代类似,对数组中的每一项给定函数语法：array.forEach(callback[, thisObject]); thisObject : 对象作为该执行回调时使用。可指定this forEach 中使用return false 并不能退出循环，但是可以中断当前循环,面试题： 123456789var a = [1, 2, 3],dist=[];a.forEach(el =&gt; &#123; if(el == 2)&#123; return false &#125; dist.push(el)&#125;);console.log(dist); // [1,3] 12345678910111213//测试filter() 返回大于2的数组var numbers1=[1,2,3,4,5,4,3,2,1];var newNumbers1 = numbers1.filter(function(item,index,array)&#123;return item&gt;2&#125;);console.log('newNumbers1',newNumbers1);//测试map() 返回原数组*2的新数组var numbers2=[1,2,3,4,5,4,3,2,1];var newNumbers2 = numbers2.map(function(item,index,array)&#123;return item*2&#125;);console.log('newNumbers2',newNumbers2);//测试some() 数组中是否有大于2的值var someNum = numbers1.some(function (value,index,arr) &#123; return value &gt;2&#125;)console.log('someNum', someNum) // true 归并方法接收两个参数：运行函数和(可选)作为归并基础的初始值，该运行函数接收四个参数：前一个值pre，当前值cur，项的索引index和数组对象arr。运行函数的返回值会自动传给下一项的第一个参数。不传入归并基础的初始值时index从第二项，即1开始。 reduce()–从前往后遍历 reduceRight()–从后往前遍历 123456var values = [1,2,3,4,5];var sum = values.reduce(function(pre,cur,index,aray)&#123; // index从0开始 return pre+cur&#125;,10);console.log('sum',sum); // 25 Date 类型这里不做详细介绍，后面会专门写一篇Date 类型的文章 RegExp 类型这里不做详细介绍，后面会专门写一篇RegExp 类型的文章 Function 类型构造函数Function()构造函数Function()可以接收任意数量的参数，但是最后一个参数始终被看做是函数体。这种方法会导致解析两次代码，(一次解析常规ECMAScript代码，第二次解析传入构造函数中的字符串)所以不推荐用此方法定义函数。但由此可以看出函数是对象，函数名是指向这个对象的指针!!!1var sum = new Function('num1','num2','return num1+num2'); 没有重载当代码里重复定义了两个同名函数，即函数名一样，则结果是该函数名指向后面定义的函数。要知道函数是对象，函数名是指针！此时第一个函数并没有从内存里删除，只是没有了可以访问的指针。 函数声明与函数表达式解析器在向执行环境中加载数据时会率先读取函数声明，并使其在执行任何代码之前可用(可访问)，即函数声明提升。而函数表达式，必须等解析器执行到它所在的代码行才会真正被解析。 函数的内部属性：arguments和this arguments：arguments接收函数调用时的传参，它的值永远与对应命名参数的值保持同步(他们的内存空间是独立的)。 arguments的callee属性是个指针，指向拥有这个arguments对象的函数。caller属性保存着调用当前函数的函数的引用，全局作用域中调用当前函数，caller为null 1234567function outer() &#123; inner();&#125;function inner() &#123; console.log(arguments.callee.caller); // 函数outer&#125;outer(); this：this引用的是函数执行的环境对象。当在全局作用域中调用函数时，this对象引用的就是window 12345678910window.color = "red"; //全局var o = &#123; color: 'blue'&#125;;function sayColor() &#123; console.log(this.color)&#125;sayColor(); //red 全局作用域下执行sayColor函数，this指向windowo.sayColor = sayColor; // 函数名sayColor是个指针，sayColor函数对象。通过赋值将这个指针赋值给o.saycoloro.sayColor() //blue this指向对象o 严格模式下arguments.callee，arguments.caller都会报错，并且不能给arguments.caller赋值。非严格模式下arguments.caller始终是undefined 函数的属性和方法两个属性： length：函数希望接收的命名参数的个数 prototype：保存所有实例方法的真正所在（ES5中prototype不可枚举，即for-in无法发现） 方法： 两个非继承而来的方法(可以扩充函数赖以运行的作用域)： apply()：接收2个参数：指定运行函数的作用域、参数数组(可选，可以是Array的实例，也可以是arguments对象) call()：与apply()的区别在于除了第一个参数外，其余参数必须逐个列举出来 1234567891011window.color = "red";var o = &#123; color: 'blue'&#125;;function sayColor() &#123; console.log(this.color)&#125;sayColor(); // red 全局作用域下引用this指向windowsayColor.call(this); // red 全局作用域下引用this指向windowsayColor.call(window); // red 作用域为window（全局）sayColor.call(o); // blue 作用域为o bind()：创建一个函数的实例，this会被绑定到传给bind()函数的值 123456789window.color = "red";var o = &#123; color: 'blue'&#125;;function sayColor() &#123; console.log(this.color)&#125;var objectSayColor = sayColor.bind(o);objectSayColor() // blue toLocaleString()、toString()、valueOf()都返回函数的代码 基本包装类型三种基本类型数据：string、number和boolean，对应的有三个特殊的引用类型：Boolean、Number和String。基本包装类型在做一些特殊的操作行为的时候，后台会自动完成下列动作： 创建String类型的一个实例 在这个实例上调用指定的方法 销毁这个实例12345var s1 = new String('some text');console.log(s1) // String &#123;"some text"&#125; var s2 = s1.substring(2);console.log(s2) // me texts1 = nul 引用类型和基本包装类型的主要区别：基本包装类型的生存期只在代码执行的瞬间123var s1= 'some text';s1.color = 'red'; //var s1= new String('some text');s1.color = 'red';s1 = nullalert(s1.color) // undefined Boolean 类型Boolean对象重写了valueOf()、toLocaleString和toString()创建Boolean对象1var falseObject = new Boolean(false); 在布尔表达式中使用Boolean对象：123456var falseObject = new Boolean(false);var result = falseObject &amp;&amp; true;console.log(result); // truevar falseValue = false;result = falseValue &amp;&amp; trueconsole.log(result); // false falseObject是对象，在布尔表达式中，所有的对象都会转换为true,因此第一次result为true1234console.log(typeof falseObject); // objectconsole.log(typeof falseValue); // booleanconsole.log(falseObject instanceof Boolean); // trueconsole.log(falseValue instanceof Boolean); // false Number 类型Boolean对象重写了valueOf()、toLocaleString和toString()继承的方法： toString()传入一个表示基数的参数，指定返回几进制数值的字符串形式 123456var num = 10;console.log(num.toString()); // 10console.log(num.toString(2)) // 1010console.log(num.toString(8)) // 12console.log(num.toString(10)) // 10console.log(num.toString(16)) // a toFixed()指定小数位返回的数值的字符串表示 1234var num1 = 10.0145;var num2 = 10.0195console.log(num1.toFixed(2)); // 10.01console.log(num2.toFixed(2)); // 10.02 toExponential 12var num = 10;console.log(num.toExponential(1)); // 1.0e+1 toPrecision() 1234var num = 99;console.log(num.toPrecision(1)); // 1e+2console.log(num.toPrecision(2)); // 99console.log(num.toPrecision(3)) // 99.0 与Boolean类型一样，使用typeof检测基本类型数值时，始终返回number，而在检测Number对象时返回object123456var numObj = new Number(10);var numVal = 10;console.log(typeof numObj); // objectconsole.log(typeof numVal); // numberconsole.log(numObj instanceof Number); // trueconsole.log(numVal instanceof Number); // false String 类型String类型的每个实例都有一个length属性，表示字符串中包含多少字符 字符方法 charAt()：以单字符字符串的形式返回给定位置的那个字符 charCodeAt()：返回给定位置的那个字符的字符编码 字符串操作方式 concat()：接受多个任意参数，拼接成新的字符串并返回 slice()：第一个参数为指定字符串的开始位置，第二个参数表示子字符串最后一个字符后面的位置，不传第二个参数则将字符串末尾作为结束位置 substr()：第一个参数为指定字符串的开始位置，第二个参数表示返回的字符个数，不传第二个参数则将字符串末尾作为结束位置 substring()：第一个参数为指定字符串的开始位置，第二个参数表示子字符串最后一个字符后面的位置，不传第二个参数则将字符串末尾作为结束位置 当传入的参数有负数时: slice将传入的负数与字符串长度相加 substring会将所有的负值都转换成0 substr会将第一个负的参数加上字符串的长度，第二个负的参数转换成0 1234567891011121314151617181920212223var str1= 'hello ';var str1Concat = str1.concat('world');console.log('=======基本包装类型========')console.log('str1：',str1);console.log('str1Concat：',str1Concat);console.log('str1Concat.length：',str1Concat.length);console.log("str1.concat('world：')",str1Concat);console.log('slice(3)：',str1Concat.slice(3)); // 从3开始console.log('substring(3)：',str1Concat.substring(3));// 从3开始console.log('substr(3)',str1Concat.substr(3));// 从3开始console.log('slice(3,7)：',str1Concat.slice(3,7));// 从3开始到7-1的位置console.log('substring(3,7)：',str1Concat.substring(3,7));// 从3开始到7-1的位置console.log('substr(3,7)：',str1Concat.substr(3,7));// 从3开始的7个数console.log('slice(-3)：',str1Concat.slice(-3));// console.log('substring(-3)：',str1Concat.substring(-3));//console.log('substr(-3)：',str1Concat.substr(-3));//console.log('slice(3,-4)：',str1Concat.slice(3,-4));// 从3到(arr.leng+(-4)) - 1)console.log('substring(3,-4)：',str1Concat.substring(3,-4));// 从3到(arr.leng+(-4)) - 1)console.log('substr(3,-4)：',str1Concat.substr(3,-4));//从3到0 字符串位置方法 indexOf() lastIndexOf() 1234var str1 = 'hello ';var str1Concat = str1.concat('world');console.log('indexof',str1Concat.indexOf('o',6)); // 7console.log('lastIndexOf',str1Concat.lastIndexOf('o',6)); // 4 trim()删除前置与后缀的所有空格，并返回结果 字符串大小写转换 toLowerCase() toLocaleLowerCase() toUpperCase() toLocaleUpperCase() 12345var str1 = 'Hello world';console.log('toLowerCase()',str1.toLowerCase()); // hello worldconsole.log('toLocaleLowerCase()',str1.toLocaleLowerCase()); // hello worldconsole.log('toUpperCase()',str1.toUpperCase()); // HELLO WORLDconsole.log('toLocaleUpperCase()',str1.toLocaleUpperCase()); // HELLO WORLD 字符串的模式匹配 match()：只接受一个正则表达式或者RegExp对象，并返回一个数组 search()：只接受一个正则表达式或者RegExp对象，并返回字符串中第一个匹配项的索引，没有则返回-1 Math 对象min()和max()方法：确定一组数据中的最小/大值。可接收任意个数值参数。 求一个数组的最大值12var values= [1,2,3,4,5,6,7,8];var max = Math.max.apply(Math,values); 舍入方法 Math.ceil()–向上取舍 Math.floor()–向下取舍 Math.round()–四舍五入 random()： 返回大于等于0小于1的随机数 (0&lt;=random&lt;1)]]></content>
      <categories>
        <category>红皮书笔记--《JavaScript高级程序设计》</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue内置组件之keepAlive]]></title>
    <url>%2F2019%2F01%2F25%2FVue%2Fvue-keepAlive%2F</url>
    <content type="text"><![CDATA[需求描述从花名册的查看/新增/修改页面进入到花名册列表页面时保持当前的搜索页面，从其他页面进入到花名册列表页时要初始化页面，即清空搜索条件并刷新当前列表。 需求分析按需求描述花名册列表页可能会缓存，其他页面不缓存。 将花名册列表页设为A页面 将查看/新增/修改页设为B页面 将其他页面设为C页面 B–&gt;A不刷新当前页，C–&gt;A刷新当前页 vue内置组件之keep-alive 它是一个抽象组件：它自身不会渲染一个DOM元素，也不会出现在父组件链中。 当组件在 内被切换，它的 activated 和 deactivated 这两个生命周期钩子函数将会被对应执行 用于保留组件状态或避免重新渲染 Props include - 字符串或正则表达式。只有名称匹配的组件会被缓存 exclude - 字符串或正则表达式。任何名称匹配的组件都不会被缓存 max - 数字。最多可以缓存多少组件实例 用法&lt;keep-alive>&lt;/keep-alive> 包裹动态组件时，会缓存不活动的组件实例，而不是销毁它们。1234567891011121314151617&lt;!-- 基本 --&gt;&lt;keep-alive&gt; &lt;component :is="view"&gt;&lt;/component&gt;&lt;/keep-alive&gt;&lt;!-- 多个条件判断的子组件 --&gt;&lt;keep-alive&gt; &lt;comp-a v-if="a &gt; 1"&gt;&lt;/comp-a&gt; &lt;comp-b v-else&gt;&lt;/comp-b&gt;&lt;/keep-alive&gt;&lt;!-- 和 `&lt;transition&gt;` 一起使用 --&gt;&lt;transition&gt; &lt;keep-alive&gt; &lt;component :is="view"&gt;&lt;/component&gt; &lt;/keep-alive&gt;&lt;/transition&gt; 是用在其一个直属的子组件被开关的情形。如果你在其中有 v-for 则不会工作。如果有上述的多个条件性的子元素， 要求同时只有一个子元素被渲染 include and excludeinclude 和 exclude 属性允许组件有条件地缓存。二者都可以用逗号分隔字符串、正则表达式或一个数组来表示:1234567891011121314&lt;!-- 逗号分隔字符串 --&gt;&lt;keep-alive include="a,b"&gt; &lt;component :is="view"&gt;&lt;/component&gt;&lt;/keep-alive&gt;&lt;!-- 正则表达式 (使用 `v-bind`) --&gt;&lt;keep-alive :include="/a|b/"&gt; &lt;component :is="view"&gt;&lt;/component&gt;&lt;/keep-alive&gt;&lt;!-- 数组 (使用 `v-bind`) --&gt;&lt;keep-alive :include="['a', 'b']"&gt; &lt;component :is="view"&gt;&lt;/component&gt;&lt;/keep-alive&gt; 匹配首先检查组件自身的 name 选项，如果 name 选项不可用，则匹配它的局部注册名称 (父组件 components 选项的键值)。匿名组件不能被匹配 max最多可以缓存多少组件实例。一旦这个数字达到了，在新实例被创建之前，已缓存组件中最久没有被访问的实例会被销毁掉。123&lt;keep-alive :max="10"&gt; &lt;component :is="view"&gt;&lt;/component&gt;&lt;/keep-alive&gt; 不会在函数式组件中正常工作，因为它们没有缓存实例。 需求实现解决方案：采用Vue内置的keepAlive组件，结合vue-router解决 router设置在需要缓存的页面设置keepAlive属性为true,其他页面不需要缓存的设为false或不设置12345678910111213&#123; name: 'staffRoster', title: '员工花名册', children: [ &#123; name: 'staffRosterList', title: '员工花名册列表', meta: &#123; keepAlive: true &#125; &#125; ]&#125; 组件引入页面设置通过include属性配置需要缓存的A页面，1234&lt;keep-alive include="staffRosterList"&gt; &lt;router-view v-if="$route.meta.keepAlive"&gt;&lt;/router-view&gt;&lt;/keep-alive&gt; &lt;router-view v-if="!$route.meta.keepAlive"&gt;&lt;/router-view&gt; A页面监听router1234567891011121314watch: &#123; '$route' (to, from) &#123; var fromName = from.name; var isFrom = (fromName != 'staffRosterNew' &amp;&amp; fromName != 'staffRosterDetail' &amp;&amp; fromName != 'staffRosterEdit' )? true:false; if(isFrom)&#123; // 清空搜索条件并刷新当前页面 this.handleClear(); this.$router.go(0); &#125;else&#123; // 重新搜索以便于刷新新增数据 this.handleSearch(); &#125; &#125;&#125;, 网上的方案vue-router 之 keep-alive假设这里有 3 个路由： A、B、C。B相当于查看/新增/删除，C相当于其他页面，A相当于花名册列表页。该方案不太符合我们的需求，因为 B C 不止一个页面。但是可以做个借鉴！ 需求 默认显示 A B 跳到 A，A 不刷新 C 跳到 A，A 刷新 方案 A 路由里面设置 meta 属性 keepAlive:true B 组件里面设置 beforeRouteLeave 1234567891011export default &#123; data() &#123; return &#123;&#125;; &#125;, methods: &#123;&#125;, beforeRouteLeave(to, from, next) &#123; // 设置下一个路由的 meta to.meta.keepAlive = true; // 让 A 缓存，即不刷新 next(); &#125;&#125;; 在 C 组件里面设置 beforeRouteLeave： 1234567891011export default &#123; data() &#123; return &#123;&#125;; &#125;, methods: &#123;&#125;, beforeRouteLeave(to, from, next) &#123; // 设置下一个路由的 meta to.meta.keepAlive = false; // 让 A 不缓存，即刷新 next(); &#125;&#125;;]]></content>
      <tags>
        <tag>Vue</tag>
        <tag>keepAlive</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Xshell5打包流程及常用命令]]></title>
    <url>%2F2019%2F01%2F25%2Fxshell%2F</url>
    <content type="text"><![CDATA[项目打包常规流程及命令 安装Xshell5安装包可进入github进行下载 新建连接new一个连接，输入新建名称(随意)、主机输入身份验证后点击确认点击连接进入项目 打包进入包所在文件夹1234// 进入文件夹cd /data/ // 打开当前项目列表ll 找到包的目录(web) 备份备份便于以后要回滚1mv web web0125_xrm_1 新建一个文件夹新建一个包的文件夹并进入该文件夹123mkdir webcd webll 放入压缩包将压缩好的代码(开发好了)拖拽进去或者用命令行放进去12rzll 解压1unzip dist.zip]]></content>
      <tags>
        <tag>原创</tag>
        <tag>Xshell5</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BOM]]></title>
    <url>%2F2019%2F01%2F23%2FJS%2FBOM%2F</url>
    <content type="text"><![CDATA[本文内容： 理解window对象–BOM的核心 控制窗口、框架和弹出窗口 利用location对象中的页面信息 使用navigator对象了解浏览器 BOM的核心–window对象window表示浏览器的一个实例。在浏览器中，window既是通过JavaScript访问浏览器的一个接口，也是ECMAScript规定的Global对象 什么是BOM? BOM(Browser Object Model)–浏览器对象模型 提供了很多对象，用于访问浏览器的功能 缺乏标准。JavaScript的标准是ECMA,DOM的标准化组织是W3C 具有全局作用域在全局作用域中声明的变量、函数都会变成window对象的属性和方法。–即可以通过window.变量名/函数名访问。 与直接在window上定义的属性有点不同:不能通过delete操作符删除 12345678var age = 20;window.color = 'red';var delColor = delete window.color;var delAge = delete window.age;console.log(delColor); // IE8及以下报错 其他浏览器返回 trueconsole.log(delAge); // IE8及以下报错 其他浏览器返回 falseconsole.log(window.color); // undefinedconsole.log(window.age); // 20 尝试访问未声明的变量会报错，但是通过查询window对象，返回undefined。可用于检测某变量是否声明 窗口关系及框架&emsp;应用有框架集(frameset)或者框架(iframe)的页面时,每个框架都拥有自己的window对象，并且保存在iframes集合中。可通过数值索引(从0开始，从左至右，从上到下)或者框架名称来访问相应的window对象。eg:window.frames[0]或者window.frames[“topFrame”]–读取的是当前框架相关的window属性： window.top：返回当前窗口的最顶层浏览器窗口。eg:top.frames[0]或者top.frames[“topFrame”]–读取的是最高层框架 window.parent：返回当前框架的直接上层框架。当没有框架时，parent等于top(他们都等于window) 1234console.log(self.name); // 为空console.log(top === parent) // trueconsole.log(top === window) // trueconsole.log(parent === window) // true 当最高层窗口不是通过window.open()打开时，window.name属性为空 window.self：实际上指向当前window，可以和window互换 窗口位置用于确定和修改window对象位置的属性和方法： screenLeft和screenTop：分别表示窗口相对于屏幕左边和上边的位置。–IE、Safari、Opera和Chrome screenX和screenY：：分别表示窗口相对于屏幕左边和上边的位置。–IE9及以上、Safari、Chrome和Firefox，Opera也支持但是与screenLeft和screenTop属性不对应 123456console.log(screenX) // Chrome为0 Firefox为-8 Edge为0 IE9为-8 IE8报错 console.log(screenY) // Chrome为0 Firefox为-8 Edge为0 IE9为-8 IE8报错 console.log(screenLeft) // Chrome为0 Firefox报错 Edge为0 IE为0console.log(screenTop) // Chrome为0 Firefox报错 Edge为0 IE为78console.log(typeof window.screenLeft) // Chrome为number Firefox为undefined IE9为number IE8为number Edge为numberconsole.log(typeof window.screenX) // Chrome为number Firefox为number IE9为number IE8为undefined Edge为number 在IE、Opera中，screenLeft和screenTop保存的是由屏幕的左边和上边到有window对象表示的页面可见区域的距离，而Safari、Chrome和Firefox中，screenY和screenTop都保存的是整个浏览器窗口相对于屏幕的坐标值。应用有框架集(frameset)或者框架(iframe)的页面时：Safari、Chrome和Firefox始终返回页面中每个框架的top.screenY和top.screenX(无论从最外层还是从某个框架访问)。而在IE、Opera中会给出框架相对屏幕边界的精确坐标。导致无法跨浏览器取得窗口的精确坐标，但是可使用moveTo()和moveBy()将窗口精确地移动到一个新位置。moveTo()：接收2个参数,新位置的x和ymoveBy()：接收2个参数,在水平和垂直方向上移动的像素数 注意:Opera和IE中默认禁用这两个函数，另外这两个函数只能对最外层window对象用，不适合iframe 窗口大小IE9、Firefox、Safari、Opera和Chrome都提供了4各相关属性：innerWidth、innerHeight、outerWidth和outerHeight。 IE9、Firefox、Safari中，outerWidth和outerHeight始终返回浏览器窗口本身的尺寸(无论从最外层还是从某个框架访问) Opera中，outerWidth和outerHeight表示页面视图容器(Opera中单个标签页对应的浏览器窗口)的大小，而innerWidth和innerHeight表示该容器中页面视图区的大小(减去边框宽度) Chrome中，innerWidth、innerHeight与outerWidth、outerHeight返回的值相等，即视口(viewport)大小而非浏览器窗口大小 获取页面可见区域的信息(DOM)：document.documentElement.clientWidth和document.documentElement.clientHeight保存着页面视口的信息–IE9、Firefox、Safari、Opera和Chrome高度差别很大 对于移动设备，window.innerWidth和window.innerHeight保存着可见视口–屏幕上可见页面区域的大小。移动IE不支持这些属性，但支持document.documentElement.clientWidth和document.documentElement.clientHeight。在其他移动浏览器中，document.documentElement度量的是布局视口–渲染后页面的实际大小。 移动设备视口：http://t.cn/zOZs0Tz 调整浏览器窗口大小：resizeTo()和resizeBy()resizeTo()：接收2个参数，浏览器窗口的新宽度和新高度resizeBy()：接收2个参数，新窗口与原窗口的宽度和高度之差 注意:Opera和IE中默认禁用这两个函数，另外这两个函数只能对最外层window对象用，不适合iframe 导航和打开窗口 弹出窗口window.open():导航到一个特定的URL,或者打开一个新的浏览器窗口。接收4个参数： 要加载的url 窗口目标(可选)：可以是已有窗口或框架的名称，或者_self、_parent、_top或_blank 一个特性字符串(可选): 设置新窗口的属性 一个表示新页面是否取代浏览器历史记录中当前加载页面的布尔值(只在打开新窗口时有效)(可选) 通过window.open()打开的窗口可以通过window.close()关闭。wroxWin.closed检测关闭属性。通过window.open()打开的窗口有一个opener属性，保存着一个指向打开它的窗口的指针。可以通过window.opener = null 断开与原窗口的通信。原窗口不会追踪打开的窗口。 安全限制 弹出窗口屏蔽程序 间歇调用和超时调用–window.setInterval()和window.setTimeout()超时调用–window.setTimeout()：在特性的时刻执行，接收要执行的代码和timeout两个参数，返回一个数值ID。 要执行的代码：可以是包含JavaScript代码的字符串(和eval()函数使用的字符串一样)，也可以是一个callback函数。传递字符串可能导致性能损失，推荐callback函数 timeout：需等待的毫秒数，时间一到就会将要执行的代码添加到任务队列中等待执行。 调用setTimeout()之后会返回一个数值ID，表示超时调用。这个超时调用ID是计划执行代码的唯一标识符，可以通过它来取消超时调用–clearTimeout(timeoutid)12345var setT = setTimeout(function () &#123; console.log('我执行了');&#125;, 1000);console.log(setT); // 1console.log(typeof setT); // number 间歇调用–window.setInterval()：按照指定的时间间隔重复执行代码，接收要执行的代码和timeout两个参数，返回一个数值ID。 要执行的代码：可以是包含JavaScript代码的字符串(和eval()函数使用的字符串一样)，也可以是一个callback函数。传递字符串可能导致性能损失，推荐callback函数 timeout：每次需等待的毫秒数，时间一到就会将要执行的代码添加到任务队列中等待执行。这里不管上次代码是否执行都会讲要执行的代码添加到任务列表。 调用setTimeout()之后会返回一个数值ID，表示超时调用。这个超时调用ID是计划执行代码的唯一标识符，可以通过它来取消超时调用–clearInterval(timeoutid)。setTimeout()如果不手动取消，则会一直执行直至页面被卸载12345678var setI = setInterval(function () &#123; console.log('我执行了setInterval');&#125;, 1000);console.log(typeof setT); // 1var setT = setTimeout(function () &#123; console.log('我执行了setTimeout'); clearInterval(setI)&#125;, 3000); 真正的开发过程中，应该尽量少用间歇调用，可以使用超时调用模拟间歇调用 系统对话框可以通过alert()、config()和prompt()调用系统对话框显示消息，这几种方法都是同步和模态的，即显示的时候代码会停止运行。 此时间歇调用和超时调用也会暂停 alert()：不会返回，接收一个提示参数 confirm()：确认框，接收一个提示参数 prompt()：提示框，提示用户输入某些信息。接收两个参数，第一个是提示语，第二个是文本框默认值 123console.log(alert('yes')) // undefinedconsole.log(confirm('yes')) // 用户点击确认按钮返回true 或 否则返回falseconsole.log(prompt('You break my heart','Michael')) // 用户点击确认按钮返回输入框信息，否则返回null 通过JavaScript打开查找和打印对话框，异步显示。 window.print()：打印 find()：返回通过测试（函数内判断）的数组的第一个元素的值。当数组中的元素在测试条件时返回 true 时, find() 返回符合条件的元素，之后的值不会再调用执行函数。如果没有符合条件的元素返回 undefined。 find() 对于空数组，函数是不会执行的。 location()对象localtion既是window对象的属性，也是document的对象。1console.log(window.location) hash：返回URL中的hash，如果URL中不包含散列则返回空字符串 host：返回服务器名称和端口号 hostname：返回服务器名称(不带端口号) href：返回完整的URL(和window.location.toString()返回值一样) pathname：返回URL中的目录和(或)文件名 port：返回端口号 protocol：返回页面使用的协议(http或https) search：返回URL的查询字符串，这个字符串以?开头 位置操作使用location对象可以通过很多方法来改变浏览器位置 location.assign()：传递一个URL–立即打开新URL并在浏览器的历史记录中生成一条记录。 window.location/location.href：设置一个URL值，会以该值调用assign()方法 修改location其他属性也可以改变 1234567891011// 原先URL为：https://blog.silviaxu.com/// 当前URL为：https://blog.silviaxu.com/#sectionlocation.hash="#section" // 当前URL为：https://blog.silviaxu.com/?page=1#sectionlocation.search = "?page=1"// 当前URL为：https://oldpost.github.io/?page=1#sectionlocation.hostname = "https://oldpost.github.io"// 当前URL为：https://oldpost.github.io/2019/01/17/JS-6/?page=1#sectionlocation.pathname = "/2019/01/17/JS-6/"// 当前URL为：https://oldpost.github.io:8086/2019/01/17/JS-6/?page=1#sectionlocation.port = 8086 禁止用户通过后退按钮回到上一个页面:replace()方法—接收要跳转的URL但是不会在历史记录中产生新纪录 1location.replace('https://blog.silviaxu.com/'); reload()：重新加载当前页面 12location.reload(); // 有可能从缓存中加载location.reload(); // 从服务器重新加载 navigator对象history对象go()、back()、forward()]]></content>
      <categories>
        <category>红皮书笔记--《JavaScript高级程序设计》</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面向对象]]></title>
    <url>%2F2019%2F01%2F17%2FJS%2FJS-6%2F</url>
    <content type="text"><![CDATA[题外话JS中的下划线_作用这里说的是变量名或者方法名中以开头的命名方式，没有具体作用，只是程序员约定俗成的定为改变量为私有变量，或改函数为私有函数 浅拷贝与深拷贝B复制了A，当修改A时，看B是否会发生变化，如果B也跟着变了，说明这是浅拷贝。这是因为A只是指向这个对象的指针，A复制给B实际上复制的是指针，而不是值的副本。注意：深拷贝本身只针对较为复杂的object类型数据12345// 浅拷贝var a=[0,1,2,3]var b = a;a[0] = 1console.log(b[0]) // 1 几种浅拷贝： 简单的赋值实现 Object.assign()实现 深拷贝 对象只有一层的话可以使用上面的：Object.assign()函数 转成 JSON 再转回来(局限性：会忽略函数) 递归拷贝 12345678910111213141516171819202122232425262728293031function deepCopy(src, dist) &#123; var dist = dist || &#123;&#125; for (var i in src)&#123; if (typeof src[i] === 'object')&#123; dist[i] = src[i].constructor === Array ? []:&#123;&#125;; deepCopy(src[i], dist[i]) &#125;else&#123; dist[i] = src[i]; &#125; &#125; return dist&#125;var shallowDist = [];var shallowDemo = ['Silvia'];var deepDemo = &#123; name: "zhangsan", age: 12, prefer: ["吃饭", "睡觉", "喝水"], state: &#123; location: "南京", cn: "中国" &#125;, sayName : function() &#123; return this.name = 'Do u love me?' &#125;&#125;//传递一个 &#123;&#125;/[] 和 （null,undefined)效果是不一样的，//传递的是null没有对象指针，执行深拷贝后dist没有赋值。var deepDist = &#123;&#125;;var shallowXX = deepCopy(shallowDemo, shallowDist);var shallowXXdeep = deepCopy(deepDemo, deepDist); Object.create()方法 123456789101112131415function deepClone(initalObj, finalObj) &#123; var obj = finalObj || &#123;&#125;; for (var i in initalObj) &#123; var prop = initalObj[i]; // 避免相互引用对象导致死循环，如initalObj.a = initalObj的情况 if (prop === obj) &#123; continue; &#125; if (typeof prop === 'object') &#123; obj[i] = (prop.constructor === Array) ? [] : Object.create(prop); &#125; else &#123; obj[i] = prop; &#125; &#125; return obj;&#125; Object.creact()方法的实质是新建一个空的构造函数F，然后让F.prototype属性指向参数对象obj，最后返回一个F的实例，从而实现让该实例继承obj的属性。动态继承了原型。在原型上添加或修改任何方法，会立刻反映在实例对象之上。但是修改实例对象不影响原型对象，可见原型。12345Object.create = function (obj) &#123; function F() &#123;&#125; F.prototype = obj; return new F();&#125;; 对象的属性类型数据属性要修改属性默认的特性，必须使用Object.defineProperty(),其接收三个参数：属性所在的对象,属性名字和一个描述符对象。Configurable属性一旦设置为fasle，则不能再重新定义其任何数据属性。Object.defineProperties()可同时设置多个属性 [[Configurable]]：能否通过delete属性从而重新定义属性，能否修改属性的特性。默认值为true [[Enumberable]]：能否通过for-in循环返回属性 [[Writable]]：能否修改属性的值 [[value]]：保存属性的数据值。默认为undefined 访问器属性不包含数据值，包含getter和setter [[Configurable]]：同数据属性 [[Enumberable]]：同数据属性 [[Get]]：读取属性时调用getter(),返回有效的值 [[Set]]：写入属性时调用setter()并传入新的值,负责决定如何处理数据 创建对象构造函数任何函数,只要能通过new操作符来调用，那它就可以作为构造函数。构造函数一般以一个大写字符开头，非构造函数以小写字母开头。构造函数作为普通函数调用时，即直接Person(params),此时的this指向当前作用域，全局中则是window。可以通过call/apply方法重新指定作用域。构造函数的缺点：构造函数中的方法在每次创建实例的时候都要重新创建一遍。123456function Person(name)&#123;this.sayName = new function("alert(this.name)")&#125; var person1 = new Person('Silvia'); var person2 = new Person('Meg'); // person1中的sayName与person2中的sayName不是同一个Function的实例。因为每定义了一个函数，就是实例化了一个对象。可以通过原型链模式解决 原型模式什么是原型？？？在JavaScript中，我们创建一个函数A(就是声明一个函数), 那么浏览器就会在内存中创建一个对象B，而且每个函数都默认会有一个属性 prototype 指向了这个对象( 即：prototype的属性的值是这个对象 )。这个对象B就是函数A的原型对象，简称函数的原型。这个原型对象B 默认会有一个属性 constructor 指向了这个函数A ( 意思就是说：constructor属性的值是函数A ) prototype属性：只要创建新函数，就会为该函数创建一个prototype属性，指向一个函数的原型对象，该对象包含可以由特定类型的所有实例共享的属性和方法。即prototype就是通过调用构造函数而创建的那个对象实例的原型对象 constructor(构造函数)属性：所有的原型对象都自动获得一个constructor属性，指向prototype属性所在的函数。即Person.prototype.constructor == Person 12345678function sayName()&#123; alert(this.name)&#125; function Person(name)&#123;this.sayName = sayName;&#125; var person1 = new Person('Silvia'); // person1中的sayName与person2中的sayName是同一个Function的实例。var person2 = new Person('Meg'); 实例与构造函数的关系：每个实例都包含一个内部属性[[prototype]]（该属性无法访问到）,该属性仅指向构造函数的原型对象Person.prototype，即实例与构造函数没有直接的关系。并且实例都不包含属性和方法。方法： isPrototypeOf()：确定对象是否存在[[prototype]]的关系 1Person.prototype.isPrototypeOf(person1) // true Object.getPrototypeOf()： Object.getPrototypeOf(person1.name)首先会在实例中搜索是否有name属性，没有则去原型对象中搜索 12Object.getPrototypeOf(person1) == Person.prototype // true 确定Object.getPrototypeOf()返回的对象时Person的原型对象 Object.getPrototypeOf(person1.name) // 'Nicholas' 取得原型对象中的name hasOwnPrototype()：检测一个属性是否存在与实例中 12345person1.hasOwnPrototype('name') // fasle person1.name = 'Silvia'; person1.hasOwnPrototype('name') // true delete person1.name; person1.hasOwnPrototype('name') // fasle 原型与in操作符两种使用方式：单独使用或者for-in 单独使用：in操作符会在通过对象能够访问给定属性时返回true。 1var isName = 'name in person1' for-in：返回所有能够通过对象访问的，可枚举的属性，其中包括存在于实例中的属性。 123456789101112131415function P()&#123;&#125; P.prototype.name = 'Nicholas'; // 为原型对象添加属性P.prototype.age = 29;P.prototype.job = 'Sofetware Engineer';P.prototype.sayName = function () &#123; console.log(this.name);&#125;;var p1 = new P();for (var prop in p1) &#123; console.log(prop + '：' + p1[prop]); //name age job sayName&#125;p1.name = 'Silvia';for (var prop in p1) &#123; console.log(prop + '：' + p1[prop]); //name age job sayName&#125; Object.keys()、Object.getOwnPrototypeName()与Object.getOwnPropertyDescriptor() Object.keys()：获取对象上所有可枚举的实例属性。接收参数为一个对象，返回包含所有可枚举属性的字符串数组。 Object.getOwnPrototypeName()：获取所有的实例属性，无论是否可枚举 Object.getOwnPropertyDescriptor()：返回某个对象属性的描述对象（descriptor） prototypy简洁写法的区别 P.ptototype在创建实例之后重写，那么此时的实例就会与构造函数断开联系。下图中的一个错误的点：改变的只是P.prototype的指针，最初原型的constructor属性还是指向构造函数P。但实际上最初原型已经被覆盖 构造函数模式与原型模式的组合使用1234567891011121314151617181920// 构造函数模式和原型模式的组合使用function Mess(name,age,job) &#123; // 构造函数模式：定义实例属性 this.name = name; this.age = age; this.job = job; this.friends = ['Meg','Pete'];&#125;Mess.prototype = &#123; // 原型模式定义方法和共享的属性 constructor : Mess, sayName : function() &#123; console.log(this.name); &#125;&#125;var mess1 = new Mess('Nicholas',29,'software Engineer');var mess2 = new Mess('Silvia', 18, 'Student');mess1.friends.push('Mark D');console.log(mess1.friends);console.log(mess2.friends);console.log(mess1.friends == mess2.friends);console.log(mess1.sayName == mess2.sayName); 继承OO语言中有两种继承方式：接口继承和实现继承。接口继承：只继承方法签名，实现继承：继承实际的方法。函数没有签名，ECMAScript中只支持实现继承，而实现继承主要依靠原型链来实现 原型链基本思想为让一个引用类型继承另一个引用类型的属性和方法。映射到构造函数、原型和实例中的关系就是：让原型对象等于另一个类型的实例，此时原型对象将包含一个指向另一个原型的指针，相应的，另一个原型中也包含着一个指向另一个构造函数的指针。 通过原型链实现继承时，不能使用对象字面量创建原型方法。因为这会重写原型，破坏生态链。 有了原型链的概念，搜索过程就会一层一层的往上查找，直到找到或者原型链末端才会停下。eg: instance.getSuperValue() 搜索实例 搜索SubType.prototype 搜索SuperType.prototype，并在此找到该方法 默认的原型所有的引用类型默认都继承了Object,而这个继承也是通过原型链实现。所以函数的默认原型都是Object的实例。因此，默认原型都包含一个内部指针[[prototype]]，指向Object.prototype。这也正是所有自定义类型都会继承toString(),valueOf()等默认方法的根本原因。 原型和实例的关系两种方法来确认： 引用类型值的原型属性会被所有实例共享 解决-借用构造函数为解决原型中包含引用类型带来的问题，在子类型构造函数的内部调用超类型构造函数。利用call()/apply() 组合继承： 原型式继承首先由道格拉斯.克罗克福提出，ES5新增Object.create()规范了原型式继承。123456789101112131415161718function object(o) &#123; function F() &#123;&#125; F.prototype = o; return new F()&#125;var personObj = &#123; name:'Nicholas', friends:['Emily','Jay']&#125;var anotherPerson = object(personObj);var yetanotherPerson = object(personObj);anotherPerson.name = 'Jasmine'; // 给实例添加name属性anotherPerson.friends.push('Jessie'); // 给原型 push 'Jessie'yetanotherPerson.name = 'Silvia'; // 给实例添加name属性yetanotherPerson.friends.push('Carry'); // 给原型 push 'Carry'console.log(personObj)console.log(anotherPerson)console.log(yetanotherPerson) 语法：Object.create(obj[,newObj])obj：新对象原型newObj：为新对象定义额外属性的对象(格式和Object.defineProperties()的第二个参数一样)，这种方式指定的属性会覆盖原型对象上的同名属性 new一个对象中间发生了什么？？？ 创建一个新对象—var person = new Object 将新对象的_proto_指向构造函数的prototype—person._proto_ = Person.prototype 指定构造函数的作用域并执行构造函数—即this指向 person :Person.call(person) 根据构造函数的返回值类型，返回相应的值：如果是this或返回值是基本类型(number、string、boolean、null、undefined)，返回新实例对象如果是引用类型,实际返回值为这个引用类型(Object/Array/function/RegExp/null) 123456789101112131415161718192021222324252627282930313233343536// 实现new原理console.log('===========实现new原理===========')//创建Person构造函数，参数为name,agefunction Person(name, age) &#123; this.name = name; this.age = age; return null&#125;function _new() &#123; //1.拿到传入的参数中的第一个参数，即构造函数名Func // 理解[].shift.call(arguments) ： shift()方法移除前端第一项,length-1,并返回移除的项。因为arguments是类数组对象，虽然他也有下标，但并非真正的数组， // 所以他不能和数组一样进行排序添加之类的操作，这种情况下 借用array.prototype对象上的方法，可以对arguments完成push，shift等操作， // array.prototypr.slice()就可以吧arguments转换成真正的数组 // Array.prototype.slice.call(arguments)能将具有length属性的对象转成数组，除了IE下的节点集合（因为ie下的dom对象是以com对象的形式实现的，js对象与com对象不能进行转换） console.log(arguments) var Func = [].shift.call(arguments); //2.创建一个空对象obj,并让其继承Func.prototype // var obj = Object.create(Func.prototype); var obj = &#123;&#125;; obj._proto_ = Func.prototype; //3.执行构造函数，并将this指向创建的空对象obj var result = Func.apply(obj, arguments) //apply（）指定运行函数的作用域obj 并传递参数 //4.返回创建的对象obj， // 如果是值类型，返回obj； // 如果是引用类型， 返回这个引用类型的对象。 console.log(typeof result) console.log(result) return typeof result === 'object' &amp;&amp; result == 'null'? result : obj;&#125;var xm = _new(Person, 'xiaoming', 18);var xm2 = new Person('xiaoming', 18);console.log(xm);console.log(xm2) // 当Person函数有返回值并且返回为对象时，返回console.log(xm2.constructor == Person); // true xm2的构造函数指向Personconsole.log(xm2 instanceof Person); // true xm2是Person的一个实例console.log(xm2 instanceof Object); // true xm2也是Object的一个实例 在回顾new 一个对象发生了什么的时候产生了一个疑问– _proto_是什么？与prototype的区别又是什么？看了知乎js中_proto_和prototype的区别和关系？再结合下面这张图，突然就明白了_proto_实际上就是这篇文章里的[[prototype]]，只不过书写方式不一样。结合原型链就很好理解new 对象的原理了。]]></content>
      <categories>
        <category>红皮书笔记--《JavaScript高级程序设计》</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[字符串和正则表达式]]></title>
    <url>%2F2019%2F01%2F17%2FES6%2FES6-2%2F</url>
    <content type="text"><![CDATA[英文原版：Understanding ECMAScript 6 UnicodeUnicode的目标是为全世界每一个字符提供全球唯一的标识符， 正则表达式u修饰符正则表达式默认将字符串中的每一个字符按照16位编码单元处理。为此，ES6给正则表达式定义了一个支持Unicode的u修饰符。 u修饰符实例添加了u修饰符，它就从编码单元操作模式切换为字符模式。 字符扩展JavaScript 只有indexOf方法，可以用来确定一个字符串是否包含在另一个字符串中。ES6 又提供了三种新方法： includes()：返回布尔值，表示是否找到了参数字符串 startsWith()：返回布尔值，表示参数字符串是否在原字符串的头部 endsWith()：返回布尔值，表示参数字符串是否在原字符串的尾部 第一个参数表示要匹配的字符，第二个参数，表示开始搜索的位置。endsWith的第二个参数表示前n个字符1234let s = 'Hello world!';console.log(s.startsWith('world', 6))// trueconsole.log(s.endsWith('Hello', 5))// trueconsole.log(s.includes('Hello', 6))// false repeat()repeat方法返回一个新字符串，表示将原字符串重复n次1'x'.repeat(3) // "xxx" 模板字符串模板字符串（template string）是增强版的字符串，用反引号（`）标识。它可以当作普通字符串使用，也可以用来定义多行字符串，或者在字符串中嵌入变量。 如果使用模板字符串表示多行字符串，所有的空格和缩进都会被保留在输出之中。 如果想清除空格，可以用trim()方法。将变量名写在${}， {}里面可以是变量，也可以是表达式，可以进行运算，以及引用对象属性。 模板字符串之中还能调用函数 还能嵌套 1234567891011121314151617181920let basket = &#123;count:1, onSale:'true'&#125;// ES5document.getElementById('result').innerHTML = 'There are &lt;b&gt;' + basket.count + '&lt;/b&gt; ' + 'items in your basket, ' + '&lt;em&gt;' + basket.onSale + '&lt;/em&gt; are on sale!';// ES6document.getElementById('result2').innerHTML=` There are &lt;b&gt;$&#123;basket.count&#125;&lt;/b&gt; items in your basket, &lt;em&gt;$&#123;basket.onSale&#125;&lt;/em&gt; are on sale!`;function fn() &#123; return "Hello World";&#125;console.log(`foo $&#123;fn()&#125; bar`) // foo Hello World bar]]></content>
      <categories>
        <category>《深入理解ES6》--笔记</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[原生JS实现移动端Touch滑动反弹]]></title>
    <url>%2F2019%2F01%2F17%2FTouch%2F</url>
    <content type="text"><![CDATA[原文地址:https://segmentfault.com/a/1190000017852497 介绍实现效果移动端没有滚动事件，通过tTouch结合JS来实现滚动反弹效果 Touch事件移动端Touch事件细分为以下三种，需要addEventListener监听： touchStart当手指触碰到屏幕的时候触发 touchmove当手指在屏幕上不断移动的时候触发 touchend当手指离开屏幕的时候触发 Touch事件触发返回event对象，该对象有三个属性包含着手指的信息：changedTouches、 targetTouches、 touches都是伪数组，里面装的是手指列表。在touchStart和touchmove的时候，这三个属性都能获取到手指的信息，在touchend时只有changedTouches对象能返回。 开始基本结构html12345678910111213141516&lt;aside class="main"&gt; &lt;div class="draw" id="draw"&gt; &lt;ul&gt; &lt;li style="background:orange"&gt;列表一&lt;/li&gt; &lt;li style="background:yellowgreen"&gt;列表二&lt;/li&gt; &lt;li style="background:yellow"&gt;列表三&lt;/li&gt; &lt;li style="background:cyan"&gt;列表四&lt;/li&gt; &lt;li style="background:orangered"&gt;列表五&lt;/li&gt; &lt;li style="background:pink"&gt;列表六&lt;/li&gt; &lt;li style="background:red"&gt;列表七&lt;/li&gt; &lt;li style="background:purple"&gt;列表八&lt;/li&gt; &lt;li style="background:violet"&gt;列表九&lt;/li&gt; &lt;li style="background:brown"&gt;列表十&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/aside&gt; css123456789101112131415161718192021222324252627282930313233343536373839404142*&#123; margin:0; padding:0;&#125;html,body&#123; width:100%;&#125;aside&#123; height:100%; width:100%;&#125;/* 列表的父盒子，限制宽高 *//* 注意设置overflow: hidden;样式后，超出这个盒子的ul将不会显示 */.draw&#123; width:60px; height:500px; border:2px solid #ccc; overflow:hidden; position:fixed; left:10px; top:50%; transform:translateY(-50%);&#125;/* li 设置了浮动， 所以 ul 要清除浮动 */ul:after&#123; content:""; display:block; visibility:hidden; height:0; clear:both;&#125;ul&#123; zoom:1;&#125;li&#123; list-style:none; float:left; width:60px; height:60px; line-height:60px; text-align:center;&#125; 首次滑动手指触摸到列表向下滑动的时候，列表应该跟着向下滑动，当手指离开屏幕的时候，列表应该停在滑动的位置实现原理 touchstart的时候，获取手指触摸的落点 A，通过这个点对象里面的 clientY属性，获取距离顶部可视区的距离 touchmove的时候，获取手指的点 B，同样的获取移动时距离顶部可视区的距离 touchmove的时候，还要做另一件事情，就是获取两点的差值（ B.clientY-A.clientY），将这个差值动态赋值给 ul， ul只需要设置向 Y轴方向偏移这个距离，就能实现列表随手指滑动 1234567891011121314var draw = document.querySelector('#draw');var ul=draw.children[0];// touchstart 时，记录手指在 Y 轴上的落点距离可视顶部距离var startY = 0;ul.addEventListener('touchstart',function(e)&#123; startY=e.changedTouches[0].clientY;&#125;)// touchmove 时，记录此时手指在 Y 轴上的落点距离可视顶部距离ul.addEventListener('touchmove',function(e)&#123; // 获取差值 var dy=e.changedTouches[0].clientY-startY; // 设置 ul 在 Y 轴上的偏移 ul.style.transform='translateY('+dy+'px)';&#125;) document.querySelectorHTML5向Web API新引入了document.querySelector以及document.querySelectorAll两个方法用来更方便地从DOM选取元素，功能类似于jQuery的选择器。使用这两个方法无法查找带伪类状态的元素，比如querySelector(‘:hover’)不会得到预期结果用法： element = document.querySelector(‘selectors’)：该方法返回满足条件的单个元素。按照深度优先和先序遍历的原则使用参数提供的CSS选择器在DOM进行查找，返回第一个满足条件的元素 elementList = document.querySelectorAll(‘selectors’)：该方法返回所有满足条件的元素，结果是个nodeList集合。需要注意的是返回的nodeList集合中的元素是非实时（no-live） 参数selectors可以包含多个CSS选择器，用逗号隔开 关于转义在提供给querySelector和querySelectorAll的参数也支持转义123456// html5&lt;aside class="main foo:bar"&gt;&lt;/aside&gt;&lt;div class="foo\bar"&gt;&lt;/div&gt;// jsvar aside = document.querySelector('.foo\\:bar');var div = document.querySelector('.foo\\\\bar'); 再次滑动出现一个BUG：第一次的时候，得到了我们想要的效果，但是在第二次的时候，我们继续向下移动了一段距离，但是 ul并没有接着第一次的位置继续向下，而是瞬间跳了上去。问题分析：虽然第二次是继续向下移动了一段距离，但是触摸结束后，最终是将此时的差值，重新赋值给了 ul的 Y轴偏移，所以视觉上“跳了上去”。解决方案：每一次滑动结束之后，都应该记录下此次滑动的距离，与之前的进行累加，待下一次滑动的时候， ul在 Y轴的偏移值应该是之前的距离加上本次滑动的距离123456789101112131415161718192021222324var draw = document.querySelector('#draw');var ul=draw.children[0];// touchstart 时，记录手指在 Y 轴上的落点距离可视顶部距离var startY = 0; // 刚触碰到屏幕的时的手指信息var centerY = 0 ; // 用来记录每次触摸时上一次的偏移距离ul.addEventListener('touchstart',function(e)&#123; startY=e.changedTouches[0].clientY;&#125;)// touchmove 时，记录此时手指在 Y 轴上的落点距离可视顶部距离ul.addEventListener('touchmove',function(e)&#123; // 获取差值 var dy = e.changedTouches[0].clientY-startY; // 上次的滑动距离加上本次的滑动距离 var tempY = centerY + dy; // 设置 ul 在 Y 轴上的偏移 ul.style.transform='translateY('+ tempY +'px)';&#125;)// touchend 时，记录此时手指在 Y 轴上的落点距离可视顶部距离ul.addEventListener('touchend',function(e)&#123; // 获取差值 var dy = e.changedTouches[0].clientY-startY; // 记录移动的距离 centerY=centerY+dy;&#125;) 限制滑动区间向上或者向下的时候没有限制，上下可以无限的滑动，甚至再用点力，就看不到列表了。为了美观和实用，这样肯定不行的，需要给它设定一个区间，设定向上或者向下最多只能留白多少。限制向下滑动最大区间： 设定向下最大区间的值比较简单，直接设定一个值，当上一次滑动的距离加上本次滑动的距离大于这个值的时候，就不让它再继续往下滑了，让他直接等于这个设定的值1234567891011121314var maxDown = 50; // 设定一个最大向下滑动的距离ul.addEventListener('touchmove',function(e)&#123; // 获取差值 var dy = e.changedTouches[0].clientY-startY; // 上次的滑动距离加上本次的滑动距离 var tempY = centerY + dy; // 当上次滑动的距离加上本次滑动的距离 大于 设定的最大向下距离的时候 if(tempY&gt;maxDown) &#123; // 直接让偏移的值 等于这个设定值 tempY=maxDown; &#125; // 设置 ul 在 Y 轴上的偏移 ul.style.transform='translateY('+ tempY +'px)';&#125;) 限制向上滑动最大区间： 向上滑动时，当 ul的底部距盒子底部的距离大于设定值的时候，不让其继续向上滑动 在IE6，IE7，IE8以及最新的的FF, Chrome中，在元素上都是offsetHeight = clientHeight + 滚动条 + 边框1234567891011121314151617181920var maxUp = -(ul.offsetHeight-draw.offsetHeight+maxDown);// 求得一个最大向上滑动的距离// touchmove 时，记录此时手指在 Y 轴上的落点距离可视顶部距离ul.addEventListener('touchmove',function(e)&#123; // 获取差值 var dy = e.changedTouches[0].clientY-startY; // 上次的滑动距离加上本次的滑动距离 var tempY = centerY + dy; // 当上次滑动的距离加上本次滑动的距离 大于 设定的最大向下距离的时候 if(tempY&gt;maxDown) &#123; // 直接让偏移的值 等于这个设定值 tempY=maxDown; &#125; // 当上次滑动的距离加上本次滑动的距离 小于 设定的最大向上距离的时候 else if(tempY &lt; maxUp)&#123; // 直接让偏移的值 等于这个设定值 tempY = maxUp; &#125; // 设置 ul 在 Y 轴上的偏移 ul.style.transform='translateY('+ tempY +'px)';&#125;) 设定反弹区间问题：一直往一个方向滑动的时候，虽然列表不会继续往下滑动，但是接着往相反方向滑动的时候，感觉列表滑不动，需要滑一段距离后，列表才会跟着走，这是为什么呢？因为滑动的过程 centerY是一直变的，列表虽然视觉上不动了，但是在 touchend事件的时候，它的 centerY值一直在累加解决：因为每一次触发 touchend事件的时候， centerY值就累加一次，所以需要在 touchend事件里做判断。我们设定一个反弹区间，就是当 centerY的值大于或者小于某个值的时候，让它触发反弹。设定向上反弹值：向上的值比较简单，设置成“0”。为什么是“0”呢？我们限定只要手指离开时，上一次的滑动距离加上本次的距离&gt;0的时候，就让它触发反弹，并且反弹回0点的位置，也就是两次滑动的距离和=0123456789101112131415// touchend 时，记录此时手指在 Y 轴上的落点距离可视顶部距离ul.addEventListener('touchend',function(e)&#123; // 获取差值 var dy = e.changedTouches[0].clientY-startY; // 记录移动的距离 centerY=centerY+dy; // 两次滑动的距离 大于 设定的 向上 反弹值时 if(centerY&gt;maxUpBounce)&#123; // 让两次滑动的距离 等于 设置的值 centerY=maxUpBounce; // 添加过渡 ul.style.transition='transform .5s'; ul.style.transform='translateY('+centerY+'px)'; &#125;&#125;) 设定向下反弹值：当列表向上滑动，滑动到列表底部的时候，只要此时再向上滑动，就让它向下反弹。向下反弹值就是 -(ul.offsetHeight-draw.offsetHeight)，只要滑动的差值小于这个设定值，就让它向下反弹，并且反弹回设定值的位置。123456789101112131415161718192021222324var maxDownBounce = -(ul.offsetHeight - draw.offsetHeight);// 向下反弹// touchend 时，记录此时手指在 Y 轴上的落点距离可视顶部距离ul.addEventListener('touchend',function(e)&#123; // 获取差值 var dy = e.changedTouches[0].clientY-startY; // 记录移动的距离 centerY=centerY+dy; // 两次滑动的距离 大于 设定的 向上 反弹值时 if(centerY&gt;maxUpBounce)&#123; // 让两次滑动的距离 等于 设置的值 centerY=maxUpBounce; // 添加过渡 ul.style.transition='transform .5s'; ul.style.transform='translateY('+centerY+'px)'; &#125; // 两次滑动的距离 小于 设定的 向下 反弹值时 else if(centerY&lt;maxDownBounce)&#123; // 让两次滑动的距离 等于 设置的值 centerY=maxDownBounce; // 添加过渡 ul.style.transition='transform .5s'; ul.style.transform='translateY('+centerY+'px)'; &#125;&#125;) 在 touchend事件的时候，给列表添加了 transition属性才会有反弹的效果，但是，下一次滑动的时候， touchmove事件的时候，这个属性还存在，所以就会出现滑动的时候有顿挫感，所以在 touchmove事件的时候，一进来就清一下过渡 ul.style.transition=’none’;。 完整代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;原生 JS 实现移动端 Touch 滑动反弹&lt;/title&gt; &lt;style&gt; *&#123; margin:0; padding:0; &#125; html,body&#123; width:100%; &#125; aside&#123; height:100%; width:100%; &#125; /* 列表的父盒子，限制宽高 */ /* 注意设置overflow: hidden;样式后，超出这个盒子的ul将不会显示 */ .draw&#123; width:60px; height:500px; border:2px solid #ccc; overflow:hidden; position:fixed; left:10px; top:50%; transform:translateY(-50%); &#125; /* li 设置了浮动， 所以 ul 要清除浮动 */ ul:after&#123; content:""; display:block; visibility:hidden; height:0; clear:both; &#125; ul&#123; zoom:1; &#125; li&#123; list-style:none; float:left; width:60px; height:60px; line-height:60px; text-align:center; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;aside class="main"&gt; &lt;div class="draw" id="draw"&gt; &lt;ul&gt; &lt;li style="background:orange"&gt;列表一&lt;/li&gt; &lt;li style="background:yellowgreen"&gt;列表二&lt;/li&gt; &lt;li style="background:yellow"&gt;列表三&lt;/li&gt; &lt;li style="background:cyan"&gt;列表四&lt;/li&gt; &lt;li style="background:orangered"&gt;列表五&lt;/li&gt; &lt;li style="background:pink"&gt;列表六&lt;/li&gt; &lt;li style="background:red"&gt;列表七&lt;/li&gt; &lt;li style="background:purple"&gt;列表八&lt;/li&gt; &lt;li style="background:violet"&gt;列表九&lt;/li&gt; &lt;li style="background:brown"&gt;列表十&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/aside&gt; &lt;script&gt; var draw = document.querySelector('#draw'); var ul=draw.children[0]; // touchstart 时，记录手指在 Y 轴上的落点距离可视顶部距离 var startY = 0; // 刚触碰到屏幕的时的手指信息 var centerY = 0 ; // 用来记录每次触摸时上一次的偏移距离 var maxDown = 50; // 设定一个最大向下滑动的距离 var maxUp = -(ul.offsetHeight-draw.offsetHeight+maxDown);// 求得一个最大向上滑动的距离 var maxUpBounce = 0; // 向上反弹 var maxDownBounce = -(ul.offsetHeight - draw.offsetHeight);// 向下反弹 ul.addEventListener('touchstart',function(e)&#123; startY=e.changedTouches[0].clientY; &#125;) // touchmove 时，记录此时手指在 Y 轴上的落点距离可视顶部距离 ul.addEventListener('touchmove',function(e)&#123; ul.style.transition = 'none'; // 获取差值 var dy = e.changedTouches[0].clientY-startY; // 上次的滑动距离加上本次的滑动距离 var tempY = centerY + dy; // 当上次滑动的距离加上本次滑动的距离 大于 设定的最大向下距离的时候 if(tempY&gt;maxDown) &#123; // 直接让偏移的值 等于这个设定值 tempY=maxDown; &#125; // 当上次滑动的距离加上本次滑动的距离 小于 设定的最大向上距离的时候 else if(tempY &lt; maxUp)&#123; // 直接让偏移的值 等于这个设定值 tempY = maxUp; &#125; // 设置 ul 在 Y 轴上的偏移 ul.style.transform='translateY('+ tempY +'px)'; &#125;) // touchend 时，记录此时手指在 Y 轴上的落点距离可视顶部距离 ul.addEventListener('touchend',function(e)&#123; // 获取差值 var dy = e.changedTouches[0].clientY-startY; // 记录移动的距离 centerY=centerY+dy; // 两次滑动的距离 大于 设定的 向上 反弹值时 if(centerY&gt;maxUpBounce)&#123; // 让两次滑动的距离 等于 设置的值 centerY=maxUpBounce; // 添加过渡 ul.style.transition='transform .5s'; ul.style.transform='translateY('+centerY+'px)'; &#125; // 两次滑动的距离 小于 设定的 向下 反弹值时 else if(centerY&lt;maxDownBounce)&#123; // 让两次滑动的距离 等于 设置的值 centerY=maxDownBounce; // 添加过渡 ul.style.transition='transform .5s'; ul.style.transform='translateY('+centerY+'px)'; &#125; &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>HTML5</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Promise与异步编程]]></title>
    <url>%2F2019%2F01%2F16%2FES6%2Fpromise%2F</url>
    <content type="text"><![CDATA[背景JavaScript引擎是基于单线程事件循环的概念构建，所以需要跟踪即将运行的代码，这些代码放在任务队列(job queue)中。事件循环(event loop)负责监控代码执行并管理任务列队。 事件模型事件模型是JavaScript中最基础的异步编程形式，eg:onclick事件，必须保证事件在添加事件处理程序之后才出发。适合于响应用户交互和完成类似的低频功能 回调模式Node.js通过普及回调函数来改进异步编程模式。与事件模式的区别：回调模式中被调用的函数是作为参数传入的。当需要多次回调时就会有多个嵌套，使得代码看起来很繁琐笨重。 Promisepromise相当于一个异步操作结果的占位符，不回去订阅一个事件，也不会传递一个回调函数给目标函数，而是让函数返回一个表示异步操作的Promise对象，未来对这个对象的操作取决于Promise的生命周期 Promise的生命周期promise 状态一旦改变则不能再变。 进行中–pending状态。此时操作尚未完成，所以它也是未处理的(unsettled) 异步操作完成–settled状态。此时操作完成 1let promise = readFile('example.txt); 代码中readFile不会开始读取文件，首先会返回一个Promise对象，此时Promise为pending状态。读取完成后，Promise可能会进入到以下两个状态中的一个： Fulfilled–Promise异步操作成功完成 Rejected–由于程序错误或者其他原因，Promise异步操作未能成功完成 内部属性[[PromiseState]]表示Promise的3种状态：pending/Fulfilled/Rejected。该属性不暴露在Promise对象上，只有在Promise的状态改变时，通过then()方法采取特定的行动。then()接收两个参数(都是可选的)： 当Promise的状态为fulfilled时要调用的函数，与异步操作相关的附加数据都会传递给这个完成函数 当Promise的状态为Rejected时要调用的函数，与失败状态相关的附加数据都会传递给这个拒绝函数 12345678910111213141516171819let promise = readfile('example.txt);promise.then(function(contents)&#123; // 成功 console.log(contents);&#125;,function(err)&#123; // 拒绝 console.error(err);&#125;);// 只执行完成promise.then(function(contents)&#123; // 成功 console.log(contents);&#125;);只执行被拒promise.then(null,function(err)&#123; // 拒绝 console.error(err);&#125;); Promise还有一个catch()方法，相当于其传入拒绝处理程序的then()。通常情况下，then()方法和catch()方法结合代码可读性更高。12345678promise.then(function(contents)&#123; // 成功 console.log(contents);&#125;).catch(function(err)&#123; // 拒绝 console.error(err);&#125;); 当Promise处于已处理状态，在这之后添加到队列中的处理程序then()/catch()就会被添加到任务列表中等待执行，所以随时可以添加处理程序。 创建未完成的PromisePromise构造函数可以创建新的Promise，该构造函数只接收一个参数：包含初始化Promise代码的执行器函数。执行器接收两个参数，分别为成功是调用的resolve()函数和失败时调用的reject()函数。1234567891011121314let bool = true; let promise = new Promise(function(resolve,retect) &#123; console.log(&apos;我是promise&apos;); if(bool)&#123; resolve(); &#125;else&#123; reject(); &#125;&#125;).then(function(contents) &#123; console.log(&apos;成功&apos;)&#125;).catch(function(err) &#123; console.log(err)&#125;)console.log(&apos;=_=&apos;); Promise构造函数在创建Promise的时候，执行器函数立即执行。执行器完成后，无论是进入resolve()还是retect()都会创建一个新的任务添加到当前任务列表的末尾。代码中首先输出’我是promise’,再输出’=_=’最后输出’成功’，就是因为console.log(‘=_=’)先被添加到任务列表，而console.log(‘成功’)是当执行器执行完之后才添加到任务列表的。要知道，Promise是异步操作的 创建已处理的Promise根据特定值创建已解决Promise的两种方法： Promise.resolve()：接收一个参数并返回一个完成状态的Promise–不会有任务编排的过程。 1234let promise2 = Promise.resolve(42);promise2.then(function(value) &#123; console.log(value)//42&#125;) Promise.reject()：接收一个参数并返回一个决绝状态的Promise–不会有任务编排的过程。 1234let promise2 = Promise.reject(42);promise2.catch(function(err) &#123; console.log(err)//42&#125;) 12return Promise.reject(new Error(&apos;error!!!&apos;))throw new Error(&apos;error!!!&apos;) 返回任意一个非 promise 的值都会被包裹成 promise 对象，即 return new Error(‘error!!!’) 等价于 return Promise.resolve(new Error(‘error!!!’))。 非Promise的Thenable对象非Promise的Thenable对象：拥有then()方法并且接收resolve和reject这两个参数的普通对象。Promise.resolve()和Promise.reject()可以接收非Promise的Thenable对象，作为参数。此时将Thenable对象转换成一个已完成的Promise123456789let thenable = &#123; then:function(resolve,reject)&#123; reject(42); &#125;&#125;;let promise = Promise.reject(thenable);promise.catch(function(value) &#123; console.log(value)//42&#125;) 执行器错误如果执行器内部抛出一个错误，则Promise的拒绝处理程序就会被调用。即执行器隐含一个try-catch块，用于捕获程序错误并传入拒绝处理程序。 全局的Promise拒绝处理如果没有拒绝处理程序则忽略报错。Promise被立即执行，但是处理程序稍后执行。 Node.js环境的拒绝处理Node.js环境下处理Promise拒绝时会触发process对象上的两个事件： unhandledRejection–在一个事件循环中，当Promise被拒绝并且没有提供拒绝处理程序时被调用。拒绝原因及被拒绝的Promise作为参数传入unhandledRejection rejectionHandled–在一个事件循环后，当Promise被拒绝并且没有提供拒绝处理程序时被调用。只有被拒绝的Promise一个参数 浏览器环境的拒绝处理浏览器环境下处理Promise拒绝时会触发window对象上的两个事件： unhandledRejection–在一个事件循环中，当Promise被拒绝并且没有提供拒绝处理程序时被调用。 rejectionHandled–在一个事件循环后，当Promise被拒绝并且没有提供拒绝处理程序时被调用。 在浏览器中，事件处理程序接收一个有以下属性的事件对象作为参数： type–事件名称(unhandledRejection/rejectionHandled) Promise–被拒绝的Promise对象 reason–拒绝值 可以用DOM0级记法的onunhandledrejection和onrejectionhandled给两个事件处理程序赋值，也可以使用addEventListener(‘unhandledrejection’)或addEventListener(‘rejectionhandled’)。 串联Promise每次调用then()/catch()实际上创建并返回了另一个Promise,只有当第一个Promise完成或被拒绝之后第二个才会被解决。.then 或者 .catch 中 return 一个 error 对象并不会抛出错误，所以不会被后续的 .catch 捕获 Promise链的返回值123456789101112131415161718192021let p1 = new Promise((resolve,reject)=&gt;&#123; console.log('我是老大'); resolve('老二');&#125;).then(value=&gt;&#123; console.log('我是'+ value);&#125;).then(value=&gt;&#123; console.log('我是老三'); throw new Error('老三'); return '老三'&#125;).then(value =&gt; &#123; console.log(value+'没有生气'); return '老三'&#125;).catch(err=&gt;&#123; console.log(err+'生气了'); throw new Error('老三');&#125;).catch(err=&gt;&#123; console.log(err.message+ '我们错了'); return '老三'&#125;).then(value=&gt;&#123; console.log(value+'和老大老二一起玩耍');&#125;); 在Promise中返回Promise可以在Promise中返回Promise，但是第二个完成处理程序then()是被添加到了第三个Psomise而不是第二个1234567891011121314151617181920let p1 = new Promise((resolve,reject)=&gt;&#123; resolve('p1')&#125;);let p2 = new Promise((resolve, reject) =&gt; &#123; resolve('p2')&#125;);p1.then(value=&gt;&#123; console.log(value); return p2&#125;).then(value =&gt; &#123;console.log(value);&#125;);// 相当于let p3 = p1.then(value=&gt;&#123; console.log(value); return p2&#125;)p3.then(value =&gt; &#123; console.log(value);&#125;); 响应多个Promise通过Promise.all()和Promise.race()来监听多个Promise，Promise.race()与Promise.all()只接受一个参数并返回一个Promise。该参数是一个包含多个受监视Promise的可迭代对象,eg数组。 Promise.all()只有当可迭代对象中所有Promise都被解决后返回的Promise才会被解决，只有当可迭代对象中所有Promise都被完成后返回的Promise才会被完成ε=(´ο｀*)))1234567891011121314151617181920212223242526let p1 = new Promise((resolve,reject)=&gt;&#123; resolve('p1')&#125;);let p2 = new Promise((resolve, reject) =&gt; &#123; resolve('p2') // reject('p2')&#125;);let p3 = new Promise((resolve, reject) =&gt; &#123; resolve('p3')&#125;);let p4 = Promise.all([p1,p2,p3])// 只有当p1/p2/p3都处于完成状态时p4.then()才会触发.then(value=&gt;&#123; console.log(Array.isArray(value)) // true console.log(value) // ['p1','p2','p3']&#125;)// 当可迭代对象的其中一个被拒绝，p4的拒绝程序立即被调用.catch(value=&gt;&#123; console.log(Array.isArray(value)) // false console.log(value) // p2&#125;)let p4 = Promise.all([p1,p2,p3]).then(value=&gt;&#123; console.log(Array.isArray(value)) // true console.log(value) // ['p1','p2','p3']&#125;) Promise.race()只要其中一个Promise被解决了返回的Promise就被解决，首先传给Promise.race()的Promise会进行判断哪一个先被解决，如果先被解决的是已完成的Promise，则返回已完成的Promise，如果先被解决的是已拒绝的Promise，则返回已拒绝的Promise。代码测试依旧p1先被解决1234567891011121314let p1 = new Promise((resolve,reject)=&gt;&#123; resolve(42)&#125;);let p2 = Promise.reject(43);let p3 = new Promise((resolve, reject) =&gt; &#123; resolve(44)&#125;);let p4 = Promise.race([p1,p2,p3])p4.then(value=&gt;&#123; console.log('then--'+value) // then--42&#125;);p4.catch(value=&gt;&#123; console.log('catch--'+value) // 没有被调用&#125;) 几个注意的点 .then 或者 .catch 的参数期望是函数，传入非函数则会发生值穿透 .then 或 .catch 返回的值不能是 promise 本身，否则会造成死循环 .then 或者 .catch 中 return 一个 error 对象并不会抛出错误，所以不会被后续的 .catch 捕获 返回任意一个非 promise 的值都会被包裹成 promise 对象，即 return new Error(‘error!!!’) 等价于 return Promise.resolve(new Error(‘error!!!’)) promise 状态一旦改变则不能再变 .then 的第二个处理错误的函数捕获不了第一个处理成功的函数抛出的错误，而后续的 .catch 可以捕获之前的错误 process.nextTick 和 promise.then 都属于 microtask，而 setImmediate 属于 macrotask，在事件循环的 check 阶段执行。事件循环的每个阶段（macrotask）之间都会执行 microtask，事件循环的开始会先执行一次 microtask]]></content>
      <categories>
        <category>《深入理解ES6》--笔记</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[函数]]></title>
    <url>%2F2019%2F01%2F15%2FES6%2FES6-3%2F</url>
    <content type="text"><![CDATA[英文原版：Understanding ECMAScript 6 参数 ES5中模拟参数 1234function makeRequest(url,timeout,callback)&#123; timeout = timeout || 2000; // 只看timeout的值是真还是假，如果为真返回timeout的值，否则返回2000。 callback = callback || function () &#123;&#125;&#125; ES5中对于函数的命名参数，如果不显示传值，则其默认为undefined。makeRequest中为timeout和callback提供了默认值，但是有个bug：当timeout传值为0时，因为0判断布尔值为false，所以返回的是2000。 ES6中的默认参数值ES6中可以为任意参数指定默认值，当制定了默认值会后，只有当不传值或者主动传入undefined时才会使用默认值123456789function doSomething() &#123;&#125;function makeRequest(url,timeout = 2000,callback = function()&#123;&#125;)&#123; console.log(timeout);&#125;makeRequest('/foo');// 2000makeRequest('/foo',undefined) // 2000makeRequest('/foo',null) // nullmakeRequest('/foo',undefined,doSomething) // 2000makeRequest('/foo',null,doSomething) // null 默认参数值对arguments对象的影响 ES5中的非严格模式下命名参数的变化会同步更新到arguments对象中。但是在严格模式下，命名参数的改变不会更新到arguments对象中。 ES6中无论是否显示定义了严格模式，arguments对象的行为都和ES5的严格模式保持一致。默认参数的存在使得arguments对象保持与命名参数分离。12345678910111213function mixArgs(first,second = 'b') &#123; console.log(arguments.length); console.log(first === arguments[0]); console.log(second === arguments[1]); first = 'c'; second = 'd'; console.log(first === arguments[0]); console.log(second === arguments[1]); console.log(arguments[1]); console.log(second);&#125;mixArgs('a') // 1 true false false false undefined dmixArgs('a','e') // 1 true true false false e d 默认参数表达式初次解析函数声明时不会调用getValue(),只有当调用add()函数且不传入第二个参数时才会调用12345678910let value = 5;function getValue() &#123; return value++;&#125;function add(first,second = getValue()) &#123; return first+second;&#125;console.log(add(1,1)); // 2console.log(add(1)); // 6console.log(add(1)); // 7 second = getValue()是函数调用的结果,second=getValue则对函数的引用，即将函数名getValue赋值给second，从而second也是一个指向该函数的指针，可通过second()引用该函数。 因此，可以使用先定义的参数作为后定义参数的默认值12345function add(first,second = first) &#123; return first+second;&#125;console.log(add(1,1)); // 2console.log(add(1)); // 2 先定义的参数不能访问后定义的参数12345function add(first,second = first) &#123; return first+second;&#125;console.log(add(1,1)); // 2console.log(add(undefined,1)); // 报错。只有不传或者传入undefined时才会使用默认值 默认参数的临时死区与let声明类似，定义参数时会为每个参数创建一个新的标识符绑定，该绑定在初始化之前不能被访问。在调用函数add(undefined,1)的时候，会执行以下代码来初始化参数值12let first = second; // 报错 此时的second还在TDZ中let second = 1; 函数参数有自己的作用域和临时死区，其与函数体的作用域是各自独立的，–即参数的默认值不可访问函数体内声明的变量 处理无命名参数 ES6引入不定参数(rest parameters):在函数的命名参数前添加三个点(…)即表示不定参数。该参数是一个数组，包含自它之后传入的所有参数。函数arguments的length属性统计的是命名参数的数量，不定参数的加入不会影响arguments.length 1234567891011121314151617function pick(object, ...keys) &#123; console.log(keys.length) // 2 console.log(arguments.length) //3 let result = Object.create(null); for(let i=0,len = keys.length;i&lt;len;i++)&#123; result[keys[i]] = object[keys[i]]; &#125; return result;&#125;let book = &#123; title:'Understanding ECMAScript 6', author:'Nicholas C.Zakas', year:2016&#125;;let bookData = pick(book,'author','year');console.log(bookData.author) // Nicholas C.Zakasconsole.log(bookData.year) // 2016 不定参数的使用限制： 每个函数最多只能声明一个不定参数，且一定要发放在所有参数的末尾 不定参数不能用于对象字面量setter。因为对象字面量setter的参数有且只有一个12345let object = &#123; set name(...value)&#123; // doSomething &#125;&#125;; 展开运算符展开运算符可以指定一个数组，将它们打散之后作为各自独立的参数传入函数。eg：Math.max可以接受任意数量的参数并返回值最大的一个,但不允许传入数组。可手动apply()实现123var value1 = 25,value2 = 30,valueArray = [25,30,12,45];console.log(Math.max(value1, value2)) // 30console.log(Math.max.apply(Math, valueArray)) // 45 使用不定参数，则无需再apply()。1console.log(Math.max(...valueArray)) // 45 还可以单独传入限定值12var values = [-25,-30,-12,-45];console.log(Math.max(...values,0)) // 0 箭头函数与传统JavaScript对比： 没有this/super/arguments/new.target绑定，其值由外围最近一层非箭头函数决定 不能new关键字调用，因为没有[[Construct]]方法，不能用作构造函数 没有原型 不可改变this绑定,eg：call()/apply()/bind()等 不支持arguments，参数只能通过命名参数和不定参数访问 不支持重复的命名参数 语法：函数参数、箭头、函数体组成 当只有一个参数，箭头紧随其后，箭头的表达式被求值后便立即返回 123456// 返回处理过的参数let reflect = value =&gt; value*3;// 相当于let reflect = function(value)&#123; return value*3;&#125; 传入2个或2个以上的参数，要给参数加上() 12345let sum = (num1,num2) =&gt; num1+num2;// 相当于let sum = function(num1,num2)&#123; return num1+num2;&#125; 函数没有参数时，要在声明的时候写一组没有内容的() 12345let getName = ()=&gt; 'Silvia';// 相当于let getName = function()&#123; return 'Silvia';&#125; 或者手动return 123let getName = ()=&gt; &#123; return 'Silvia';&#125;; 空函数要加上{} 1let getName = ()=&gt; &#123;&#125;; 返回对象字面量，要将字面量包括在()里 12345let getName = ()=&gt; (&#123;name:'Silvia'&#125;);// 或let getName = function()&#123; return &#123;name:'Silvia'&#125;;&#125; 箭头函数与立即执行函数123456789101112131415let person = function(name) &#123; return &#123; getname:function()&#123; return name; &#125; &#125;&#125;('Silvia');// 相当于let person = ((name) =&gt;&#123; return &#123; getname: function () &#123; return name; &#125; &#125;&#125;)('Silvia'); 箭头函数与this绑定1234567891011121314let PageHandler = &#123; id:'123456', init:function()&#123; console.log(this); // PageHandler对象 document.addEventListener('click',function (event) &#123; console.log(this); // #document对象 this.doSomething(event.type); //报错 this.doSomething is not a function &#125;,false); &#125;, doSomething:function(type)&#123; console.log('PageHandler'+type+'for'+this.id) &#125;&#125;;PageHandler.init() this值随着执行上下文而改变，点击报错因为此时的this绑定的是document,可以通过bind()方法显示的将this绑定到PageHandler对象1234567891011121314let PageHandler = &#123; id:'123456', init:function()&#123; console.log(this); // PageHandler对象 document.addEventListener('click',(function (event) &#123; console.log(this); // PageHandler对象 this.doSomething(event.type); &#125;).bind(this),false); &#125;, doSomething:function(type)&#123; console.log('PageHandler'+type+'for'+this.id) &#125;&#125;;PageHandler.init() 但是此时新创建了一个函数，它的this被绑定到当前的this。可使用箭头函数123456789101112let PageHandler = &#123; id:'123456', init:function()&#123; console.log(this); // PageHandler对象 document.addEventListener('click', event =&gt;this.doSomething(event.type) ,false); &#125;, doSomething:function(type)&#123; console.log('PageHandler'+type+'for'+this.id) &#125;&#125;;PageHandler.init() 箭头函数中没有绑定this值，只能通过查找作用域链来决定。如果箭头函数被非箭头函数包含，则this为外围最近一层非箭头函数this，否则this为undefined 箭头函数和数组诸如sort()、map()和reduce()等接受回调函数的数组方法，都可以通过箭头函数语法简化编码过程12var values = [5,6,2,8]var result = values.sort((a,b)=&gt; a-b); 箭头函数和arguments箭头函数没有arguments绑定，但是箭头函数可以访问外围函数的arguments对象1234function createArrowFunc() &#123; return ()=&gt;arguments[0]&#125;console.log(createArrowFunc(5)()) // 5 箭头函数可以被typeof、instanceof识别12345function createArrowFunc() &#123; return () =&gt; arguments[0];&#125;console.log(typeof createArrowFunc(5)) // functionconsole.log(createArrowFunc(5) instanceof Function) // true 尾调用优化尾调用:函数作为另一个函数的最后一条语句被调用。1234567function doSomthingElse() &#123; console.log('我被调用了');&#125;function doSomthing() &#123; return doSomthingElse() // 尾调用&#125;doSomthing() // 我被调用了 创建一个新栈，将doSomthingElse压入栈中实现调用。当调用栈变得过大 优化栈调用严格模式下，如果满足一下条件，尾调用不再创建新的栈，而是清除并重用当前栈帧。 尾调用不访问当前栈帧的变量(即函数不是一个闭包) 在函数内部，尾调用是最后一条语句 尾调用的结果作为函数值返回，并且为立即返回 1234567891011121314151617// 无法优化function factorial(n) &#123; if(n&lt;=1)&#123; return 1; &#125;else&#123; return n*factorial(n-1); // 没有立即返回 &#125;&#125;// 优化代码function factorial(n,p=1) &#123; if(n&lt;=1)&#123; return 1*p; &#125;else&#123; let result = n*p return factorial(n-1,result); // 没有立即返回 &#125;&#125;]]></content>
      <categories>
        <category>《深入理解ES6》--笔记</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[立即执行函数, 模块化, 命名空间]]></title>
    <url>%2F2019%2F01%2F14%2F33concepts%2Fmodule%2F</url>
    <content type="text"><![CDATA[什么是模块？模块就是实现特定功能的一组方法，只要把不同的函数（以及记录状态的变量）简单地放在一起，就算是一个模块。模块与模块之前互不影响，且不暴露内部成员。 模块化模块化主要为了解决两个问题——“命名空间冲突”，“文件依赖管理”，可以使用立即执行函数+闭包 当立即执行函数和window.onload为同一层级时，无论代码先后立即执行函数都会先执行！ Javascript模块的基本写法:123456// 大括号()是为了要把匿名函数转换为表达式，js在"预编译"阶段, 会解释函数声明, 但却会忽略表式.var module1= (function(params) &#123; var stuff = &#123;name : 'Silvia' &#125;; console.log(stuff.name); // Silvia&#125;)(module1);console.log(stuff); // 报错 stuff is not defined 放大模块:必须分成几个部分，或者一个模块需要继承另一个模块1234567891011121314151617var module1= (function() &#123; var stuff = &#123;name : 'Silvia' &#125;; var m1 = function () &#123; console.log('m1') &#125;; var m2 = function () &#123; console.log('m2') &#125;; return &#123;m1:m1,m2:m2&#125;&#125;)(module1);// 给module1新增方法m3var module1 = (function (mod) &#123; mod.m3 = function()&#123; console.log('m3') &#125; return mod&#125;)(module1); 宽放大模式: “立即执行函数”的参数可以是空对象123456var module1 = (function (mod) &#123; mod.m3 = function()&#123; console.log('m3') &#125; return mod&#125;)(module1 || &#123;&#125;); // 不加 || &#123;&#125; 报错 NewFile(1).html:51 Uncaught TypeError: Cannot set property 'm3' of undefined 参数参数分为形参和实参1234567891011121314151617181920212223var module2 = &#123; count:3&#125;var module1= (function() &#123; var stuff = &#123;name : 'Silvia' &#125;; var m1 = function () &#123; console.log('m1') &#125;; var m2 = function () &#123; console.log('m2') &#125;; return &#123;m1:m1,m2:m2&#125;&#125;)(module1);// 给module1新增方法m3var module3 = (function (mod,mod2, undefined) &#123; mod.count = mod2.count+1; mod.m3 = function()&#123; console.log('m3') &#125; return mod&#125;)(module1, module2);console.log(module3.count); // 4console.log(module2.count); // 3 其中module1, module2就是实参，mod,mod2, undefined则为形参。普通参由实际变量传入指定，可以为任何类型的变量。特殊形参undefined： 防止特殊值undefined被恶意代码篡改 压缩代码可以压缩undefined 模块化构建工具（解决依赖管理）几个概念: 包管理工具(npm)、模块化构建工具(webpack/requireJS/seaJS等)、模块化规范(AMD/CMD/CommonJS/es6等)包管理工具：安装、卸载、更新、查看、搜索、发布包模块化构建工具：组织前端模块模块化规范：如何来组织你的代码 模块化规范–require与import的区别require使用与CommonJs规范，import使用于Es6模块规范；所以两者的区别实质是两种规范的区别 相关参考：Javascript模块化编程（一）：模块的写法javascript模块化编程-详解立即执行函数表达式IIFE前端模块化——技术选型谈谈Js前端模块化规范]]></content>
      <categories>
        <category>33个JavaScript概念</category>
      </categories>
      <tags>
        <tag>33concepts</tag>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JSON]]></title>
    <url>%2F2019%2F01%2F11%2FJS%2FJSON%2F</url>
    <content type="text"><![CDATA[要点 JSON是一个轻量级的数据格式，可以简化表示复杂数据结构的工作量。 使用JavaScript的子集表示对象、数组、字符串、数值、Boolean和null。 ES5中定义了一个原生的JSON对象 语法支持以下三种类型的值： 简单值：字符串、数值、布尔值和null,但不支持JavaScript中的特殊值undefined 对象：一种复杂数据类型的值，表示一组无序的键值对。键值对中的值可以是简单值也可以是复杂数据类型的值 数组：一种复杂数据类型的值，一组有序的值的列表。可通过数值索引访问其中的值，数组的值可以是简单值也可以是复杂数据类型的值。 简单值1"Hello Silvia" 实际运用中，JSON更多的用来表示复杂数据类型 复杂数据类型–对象与JavaScript字面量的不同： 没有声明变量 没有末尾分号 JSON中对象的属性必须加双引号，单引号也会报错。 123&#123; "name":"Silvia"&#125; 复杂数据类型–数组JSON数组采用的就是JavaScript中的数组字面量形式，数组也没有变量和分号123&#123; "Silvia","Jessie"&#125; 解析与序列化将JSON数据解析为有用的js对象。 JSON对象早期的JSON解析器基本上使用的是JavaScript的eval()函数，其可以解析、解释并返回JavaScript对象和数组。ES5中定义了JSON对象。JSON对象的两个方法：stringify()和parse() stringify()：把JavaScript对象序列化为字符串 parse()：把JSON字符串解析为原生JavaScript对象 123456789var book = &#123; title:"The Mango Street", author:"Silvia", edition:3, year:2019&#125;var jsonText = JSON.stringify(book);var bookCopy = JSON.parse(jsonText);console.log(jsonText); // &#123;"title":"The Mango Street","author":"Silvia","edition":3,"year":2019&#125; 默认情况下，JSON.stringify()输出的值不包含任何空格字符或缩进。在序列化JavaScript对象时，所有函数及原型成员都会被有意忽略，值为undefined的任何属性也会被跳过。最终输出的值为有效JSON数据类型的实例属性。JSON.parse()输出的值与原book是相互独立的。如果传给JSON.parse()的字符串不是有效的JSON,该方法会报错 序列化选项JSON.stringify()JSON.stringify()的传递参数除了JavaScript对象外，还有2个可选参数。第一个可选参数是个过滤器，可以是数组或者函数，第二个可选参数是一个选项，表示是否 过滤器–replacer如果过滤器参数是数组，那么JSON.stringify()的结果将只包含数组中列出的属性 1234567var book = &#123; title:"The Mango Street", author:'Silvia', edition:3, year:2019&#125;var jsonText = JSON.stringify(book,['title','author']); // &#123;"title":"The Mango Street","author":"Silvia"&#125; 如果过滤器是函数，该函数接收2个参数：属性(键)名和属性值。属性名只能是字符串，但是当值并非键值对结构的值时(eg数组),键名可以是空字符串。函数的如果返回undefined，那么相应的属性将会被忽略。 12345678910111213141516171819var book = &#123; title:"The Mango Street", author:['Silvia','Jessie'], edition:3, year:undefined&#125;var jsonText = JSON.stringify(book,function(key,value) &#123; console.log(key); // 第一次为空 console.log(value); // 第一次为 book对象 switch (key) &#123; case "author": return value.join(" ") break; default: return value break; &#125;&#125;);console.log(jsonText); // &#123;"title":"The Mango Street","author":"Silvia,Jessie","edition":3,"year":2019&#125; 一定要提供default项否则报错 选项用于控制结果中的缩进和空白符。如果这个参数是数值，那它表示每个级别缩进的空格数(最大为10)。如果是字符串，则这个字符串将在JSON字符串中被用作缩进字符(不再使用空格)，长度最长也只能是10个字符长。 toJSON()方法 1234567891011var book = &#123; title:"The Mango Street", author:['Silvia','Jessie'], edition:3, year:2019, toJSON:function() &#123; return this.title &#125;&#125;var jsonText = JSON.stringify(book)console.log(jsonText); // "The Mango Street" book对象被序列化为字符串而非对象。toJSON()可以返回任何值，当为undefined时，如果包含它的对象嵌入在另一个对象中，会导致它的值变为null，而如果是顶级对象，结果就是undefined。 对象序列化的顺序： 如果存在toJSON()并且能通过toJSON()取得有效的值，则调用该方法。否则返回对象本身 如果提供了第二个参数，应用这个函数过滤器。传入函数过滤器的值是第一步返回的值 对第二步返回的值进行相应的序列化 如果提供第三个参数，执行相应的格式化 解析选项JSON.parse()JSON.parse()方法也可以接收一个参数，该参数是一个函数–还原函数(reviver)，将在每个键值对上调用。还原函数如果返回undefined，则表示要从结果中删除相应的键，如果返回其他值，则表示要在结果中插入该值。12345678910111213141516var book = &#123; title:"The Mango Street", author:['Silvia','Jessie'], edition:3, year:2019, releaseDate:new Date(2019,1,10)&#125;var jsonText = JSON.stringify(book);var bookCopy = JSON.parse(jsonText,function(key,value) &#123; if(key == "releaseDate")&#123; return new Date(value); &#125;else&#123; return value; &#125;&#125;)console.log(bookCopy.releaseDate.getFullYear()); // 2019]]></content>
      <categories>
        <category>红皮书笔记--《JavaScript高级程序设计》</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>JSON</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第4章变量、作用域和内存问题]]></title>
    <url>%2F2019%2F01%2F10%2FJS%2FJS-4%2F</url>
    <content type="text"><![CDATA[本文内容： 理解基本类型和引用类型 理解执行环境及作用域 了解垃圾收集 基本类型和引用类型基本类型值指的是简单的数据段。5种基本数据类型：Undefined Null Boolean Number String JS可以操作保存在变量中的实际的值–基本类型按值访问引用类型值指的是可能由多个值构成的对象。因为引用类型保存在内存中，JS不允许直接访问内存的位置，即不能直接访问内存空间。所以操作引用类型实际上操作的是对象的引用(指针)–引用类型按引用访问。 当复制保存着对象的某个变量时，操作的是对象的引用。但在为对象添加属性时，操作的是实际的对象–图灵社区“壮壮的前端之路”注 只能给引用类型动态添加(删除/修改)属性复制变量值 复制基本类型：在变量对象上创建一个新值，然后把该值复制到为新变量分配的位置上。两个变量完全独立互不影响。 12345var num1 = 5;var num2 = num1;num1 = 6;console.log(num1); // 6console.log(num2); // 5 复制引用类型：也会将储存在变量对象中的值复制一份放到为新变量分配的位置上。但这个副本是个指针–即复制的是指针，两个变量共同指向同一个内存空间。 12345var obj1=new Object();var obj2 = obj1;obj1.name = 'Silvia';console.log(obj1.name); // Silviaconsole.log(obj2.name); // Silvia 传递参数ECMAScript中所有函数的参数都是按值传递–把函数外部的值复制给函数内部的参数与复制变量值一样，实际上传递过来的参数会复制到一个函数的局部变量(arguments对象中的一个元素，或者是命名参数)。如果传递的是引用类型，那么复制的副本实际上就是变量在内存中的地址(指针)，因此这个局部变量会影响到函数的外部。1234567891011121314151617181920212223function addTen(num) &#123; if(typeof num == 'object')&#123; num.count += 10; return num.count &#125; else&#123; num +=10; return num &#125;&#125;// 传递基本类型var count = 20;var result1 = addTen(count);console.log(count); // 20console.log(result1); // 30var obj3 = &#123;count:20&#125;;// 实际上传递的也是基本类型var result2 = addTen(obj3.count);console.log(obj3.count); // 20console.log(result2); // 30// 传递引用类型var result2 = addTen(obj3);console.log(obj3.count); // 30console.log(result2); // 30 检测类型 typeof操作符–检测是什么类型 12345678910111213141516var a = 'Silvia';var b= true;var i = 22;var u;var n = null;var f = new Function();var o = new Object();var arr = new Array(); console.log(typeof a); // stringconsole.log(typeof b); // booleanconsole.log(typeof i); // numberconsole.log(typeof u); // undefinedconsole.log(typeof n); // objectconsole.log(typeof f); // functionconsole.log(typeof o); // objectconsole.log(typeof arr); // object instanceof操作符–检测引用类型是什么类型的对象,如果变量是给定引用类型的实例(根据原型链来识别)则返回true。语法：result = variable instanceof constructor 123456console.log(a instanceof String); // falseconsole.log(f instanceof Function); // trueconsole.log(f instanceof Object); // trueconsole.log(n instanceof Object); // falseconsole.log(arr instanceof Object); // trueconsole.log(arr instanceof Array); // true 执行环境及作用域执行环境定义了变量或函数有权访问的其他数据，决定了他们各自的行为。每个执行环境都有一个与之关联的变量对象，环境中定义的所有变量和函数都保留在这个对象上。每个函数都有自己的执行环境，当执行流进入一个函数时，函数的执行环境就会被推入一个环境栈中，在函数执行之后，栈将其执行环境弹出，把控制权返还给之前的执行环境。当代码在一个环境中执行时，会创建变量对象的一个作用域链(scope chain)。其作用是保证对执行环境有权访问的所有变量和函数的有序访问。 好了上面的话有点搞不清楚，记住这两点： 函数在定义时就会确定他的作用域（静态） 调用的时候才会创建一个执行上下文与作用域链(动态) 那么什么是作用域链？？？作用域的前端，始终是当前执行的代码所在的环境的变量对象。如果这个环境是函数，则将其活动对象作为变量对象。活动对象最开始只包含一个变量，即arguments对象。下一个变量对象来自包含(外部环境)，在下一个则来自下一个包含对象。这样一直延续到全局执行环境。全局执行环境的变量对象始终是作用域链的最后一个对象。标识符解析是沿着作用域链一级一级的搜索标识符的过程，搜索从作用域链的前端开始，即当前执行函数的作用域。然后逐级往后回溯，直至找到标识符，找不到则导致报错。eg:1234567891011var color = 'blue';function changeColor() &#123; console.log(color); // blue if(color === 'blue')&#123; color = 'red'; &#125;else&#123; color = 'blue' &#125;&#125;changeColor();console.log(color); // red 调用函数changeColor()，搜索color标识符，先在当前函数(changeColor)中查找，没有找到定义的color标识符，则到全局环境中查到。找到标识符color并且值为blue，if条件满足将color改为red。这里函数体内访问的是全局下的color，所以修改的也是全局下的color。要记住：内部环境能通过作用域链访问所有的外部环境，但外部环境不可以访问内部环境中的任何变量和函数。 延长作用域执行环境只有2种：全局和局部。可以通过在作用域链的前端临时增加一个变量对象延长作用域链，该变量会在代码执行完毕之后被移除。 try-catch的catch语句：创建一个新的变量对象，其中包含被抛出错误对象的声明 with语句：将指定的对象添加到作用域中 var href = 'Silvia'; function buildUrl() { var qs = '?debug=true'; with(location){ var url = href + qs; } return url; } var url = buildUrl(); console.log(url) // 输出为当前网页的location.href+'?debug=true'而不是 Silvia?debug=true 调用函数buildUrl()，当引用href时，首先在当前执行环境(location)中搜索，location.href存在则不会继续往上查找。 没有块级作用域 在循环体内var定义的变量在循环外也能访问 初始化变量时如果没有加var声明，该变量就会自动添加到全局变量中。否则添加到最接近的环境中 垃圾收集JavaScript具有自动垃圾收集机制–执行环境会负责管理代码执行过程中使用的内存。常用的垃圾收集方式： 标记清除 引用计数 管理内存优化内存占用的最佳方式：解除引用–为执行中的代码只保留必要的数据。一旦数据不再用，最好通过将其值设置为null来释放其引用解除引用适用于全局变量和全局对象的属性。解除不意味着自动回收该值所占的内存，解除的真正作用是让其脱离执行环境，以便下次垃圾收集器将其回收。]]></content>
      <categories>
        <category>红皮书笔记--《JavaScript高级程序设计》</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[块级作用域的绑定]]></title>
    <url>%2F2019%2F01%2F06%2FES6%2FES6-1%2F</url>
    <content type="text"><![CDATA[英文原版：Understanding ECMAScript 6 var声明及变量提升(Hoisting)机制变量提升(Hoisting)机制：var在函数作用域或者是全局作用域中声明的变量，变量的声明被提升到该作用域的顶部。但是初始化依旧留在原处执行。–即在初始化之前可以访问该变量，但是因为未初始化，所以值为undefined。123console.log(a); // undefinedvar a='123';console.log(a); // 123 ES6中引入块级作用域来强化对变量生命周期的控制–let和const块级声明用于声明在指定块的作用域之外无法访问的变量，其作用域存在于： 函数内部 块中（字符 { 和 } 之间的区域） 其特点： 变量不会被提升 禁止重复声明如果当前作用域中已经存在某个标识符，此时就不能再通过let/const声明该标识符。否则抛出错误。但是如果当前作用域内嵌另一个作用域，便可在内嵌的作用域中用let/const声明同名变量。此时内嵌的作用域中声明的变量会遮蔽当前作用域中的变量。 123456var count = 30;if(count)&#123; let count = 20 console.log(count) // 20&#125;console.log(count) // 30 无论是严格模式还是非严格模式下，都不可以为const定义的常量再赋值。否则会报错但如果const定义的是对象时，则可以修改对象的值,因为此时const定义的是指向该值的指针—const声明不允许修改绑定，但允许修改绑定的值 12345const c = &#123;a:123&#125;console.log(c.a) // 123c.a = 321;console.log(c.a) // 321c = &#123;b:123&#125; // Uncaught TypeError: Assignment to constant variable. 临时死区(temporal dead zone)或TDZ：js引擎在扫描代码发现变量声明时，要么提升变量声明(var)，要么将声明放到TDZ中(let/const)。访问TDZ中的变量就会触发运行时错误，只有执行过变量声明语句后，变量才会从TDZ中移出。 for循环在每次迭代时let都会创建新的绑定 12345678910var funcs = [];for(let i=0;i&lt;10;i++)&#123; funcs.push(function() &#123; console.log(i) &#125;)&#125;funcs.forEach(function(func) &#123; func();&#125;)// 输出为 0到9 const在for循环中的声明：普通的for循环会报错，但是在for-in/of循环中和let一致，此时每次的迭代不会修改已有绑定，而是会创建一个新绑定 123456789101112131415var funcs = [], object = &#123; a:1, b:2, c:3 &#125;;for (const key in object) &#123; funcs.push(function() &#123; console.log(key) &#125;)&#125;funcs.forEach(function(func) &#123; func();&#125;)// 输出为 a b c 全局块作用域绑定全局作用域下，会创建一个新的全局变量作为全局对象(window)的属性。意味着var可能会覆盖一个已经存在的全局变量。 12var RegExp = 'hello';console.log(window.RegExp); // hello 此时全局对象RegExp被var声明覆盖 全局作用域下，let/const会创建一个新的绑定，但该绑定不会添加到全局对象上。即let和const声明不能覆盖全局变量,只能遮蔽它。 123let RegExp = 'hello';console.log(RegExp); // helloconsole.log(window.RegExp); // ƒ RegExp() &#123; [native code] &#125; 函数声明ES5 规定，函数只能在顶层作用域和函数作用域之中声明，不能在块级作用域声明。ES6 在附录 B里面规定： 允许在块级作用域内声明函数。 函数声明类似于var，即会提升到全局作用域或函数作用域的头部。 同时，函数声明还会提升到所在的块级作用域的头部 ES6 的块级作用域允许声明函数的规则，只在使用大括号的情况下成立，如果没有使用大括号，就会报错]]></content>
      <categories>
        <category>《深入理解ES6》--笔记</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[兼容性问题收集]]></title>
    <url>%2F2019%2F01%2F05%2Fcompatibility%2F</url>
    <content type="text"><![CDATA[JS Web Storage：localStorage和sessionStorage在IE下的兼容12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758var util = &#123; // 获取 localStorage getItem:function (item) &#123; var value; if (this.hasLocalSotrage()) &#123; try &#123; value = sessionStorage.getItem(item); &#125; catch (error) &#123; console.error('sessionStorage.getItem报错， ', error.message) &#125; finally &#123; return value; &#125; &#125; else &#123; return this.getCookie(item); &#125; &#125;, // 设置 localStorage setItem:function (key, value, day) &#123; if (this.hasLocalSotrage()) &#123; try &#123; sessionStorage.setItem(key, value); &#125; catch (error) &#123; console.error('sessionStorage.setItem报错， ', error.message) &#125; &#125; else &#123; this.setCookie(key, value, day); &#125; &#125;, // 判断浏览器是否支持 hasLocalSotrage hasLocalSotrage:function () &#123; return window.Storage &amp;&amp; window.sessionStorage &amp;&amp; window.sessionStorage instanceof Storage &#125;, //设置cookie setCookie:function (key, value, day) &#123; var t = day || 30; console.log(t) var d = new Date(); d.setTime(d.getTime() + (t * 24 * 60 * 60 * 1000)); var expires ="expires="+ d.toUTCString(); document.cookie = key + "=" + value + "; " + expires; &#125;, //获取cookie getCookie:function (name) &#123; var arr, reg = new RegExp("(^|)" + name + "=([^]*)(|$)"); if (arr = document.cookie.match(reg)) &#123; return arr[2]; &#125; else &#123; return null; &#125; &#125;&#125; 感谢localStorage本地持久化兼容IE浏览器 IE下不支持 addEventListener CSS3 transformtransform：translateY(-50%);-webkit-transform: translateY(-50%); / for Chrome || Safari /-moz-transform: translateY(-50%); / for Firefox /-ms-transform: translateY(-50%); / for IE /-o-transform: translateY(-50%); / for Opera /]]></content>
      <tags>
        <tag>兼容性</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1-调用堆栈(Call Stack)及JavaScript 执行机制]]></title>
    <url>%2F2019%2F01%2F02%2F33concepts%2Fconcepts_1%2F</url>
    <content type="text"><![CDATA[JavaScript 如何工作？原文链接：[译] JavaScript 如何工作：对引擎、运行时、调用堆栈的概述 JavaScript 引擎 (V8引擎)JavaScript 引擎是执行JavaScript 代码的程序或者说是解释器。JavaScript引擎能够被实现成标准解释器或者是能够将 JavaScript以某种方式编译为字节码的即时编译器。V8引擎是驱动NodeJS的核心。V8引擎由2部分组成： 内存堆：这是内存分配发生的地方 调用栈：这是你的代码执行时的地方 浏览器内核：Mozilla(Gecko)–(Firefox等) WebKit–(Safari、Chrome等) Opera(presto)–(Opera) Trident–(IE) 运行时浏览器使用的API浏览器运行时，除了引擎提供的API，还有浏览器提供的Web API，eg:DOM、AJAX、setTimeOut等，还有事件循环(Event Loop)和回调队列(Callback Queue)。 调用栈(LIFO 后进先出)JavaScript 是一门单线程的语言，这意味着它只有一个调用栈，因此，它同一时间只能做一件事。调用栈/执行栈: 是一种数据结构，记录在程序中的位置。当有任务进来时，将其放在栈顶，当从这个函数返回的时候，就会将这个函数从栈顶弹出。123456789function multiply(x, y) &#123; console.log('我进来了') return x * y;&#125;function printSquare(x) &#123; var s = multiply(x, x); console.log(s);&#125;printSquare(5); 结果：12我进来了25 每一个进入调用栈的都称为__调用帧__。当异常发生的时候堆栈追踪是怎么被构造的，堆栈的状态是如何的？eg:12345678910function foo() &#123; throw new Error('SessionStack will help you resolve crashes :)');&#125;function bar() &#123; foo();&#125;function start() &#123; bar();&#125;start(); 堆栈溢出:某一时刻，调用栈中的函数调用的数量超过了调用栈的实际大小，浏览器决定干掉它，抛出一个错误1234function foo() &#123; foo();&#125;foo(); 并发与事件循环由于 JavaScript 只有一个调用堆栈，引发的思考：当某段代码运行变慢时会发生什么?相关优化请看[译] JavaScript 如何工作：在 V8 引擎里 5 个优化代码的技巧 为什么要创建 V8 引擎?V8 最初被设计出来是为了提高浏览器内部 JavaScript 的执行性能。为了获取更快的速度，V8 将 JavaScript 代码编译成了更加高效的机器码，而不是使用解释器。它就像 SpiderMonkey 或者 Rhino (Mozilla) 等许多现代JavaScript 引擎一样，通过运用即时编译器将 JavaScript 代码编译为机器码。而这之中最主要的区别就是 V8 不生成字节码或者任何中间代码。 理解JavaScript中的执行上下文和执行栈原文：[译] 理解 JavaScript 中的执行上下文和执行栈 执行上下文的类型 全局执行上下文：任何不在函数内部的代码都在全局上下文中。它会执行两件事：创建一个全局的 window 对象（浏览器的情况下），并且设置 this 的值等于这个全局对象。一个程序中只会有一个全局执行上下文 函数执行上下文：每当一个函数被调用时, 都会为该函数创建一个新的上下文。每个函数都有它自己的执行上下文，不过是在函数被调用时创建的。函数上下文可以有任意多个。每当一个新的执行上下文被创建，它会按定义的顺序（将在后文讨论）执行一系列步骤。 val 函数执行上下文 — 执行在 eval 函数内部的代码也会有它属于自己的执行上下文。 执行栈&#8194;&#8194;JavaScript管理执行上下文：JS引擎第一次运行代码时，首先会创建一个全局的执行上下文并压入栈顶，当有函数调用时，会为该函数创建一个新的执行上下文并压入栈顶。JS引擎执行位于栈顶的函数，该函数执行结束后执行上下文从栈中弹出，控制流程到达当前栈的下一个上下文。1234567891011let a = 'Hello World!';function first() &#123; console.log('Inside first function'); second(); console.log('Again inside first function');&#125;function second() &#123; console.log('Inside second function');&#125;first();console.log('Inside Global Execution Context'); 如何创建上下文？创建上下文会发生三件事： this绑定 创建词法环境 创建变量环境组件 this绑定在全局执行上下文中，this 的值指向全局对象。(在浏览器中，this引用 Window 对象)。在函数执行上下文中，this 的值取决于该函数是如何被调用的。如果它被一个引用对象调用，那么 this 会被设置成那个对象，否则 this 的值被设置为全局对象或者 undefined（在严格模式下）。12345678let foo = &#123; baz: function() &#123; console.log(this); &#125;&#125;foo.baz(); // 'this' 引用 'foo', 因为 'baz' 被对象 'foo' 调用let bar = foo.baz;bar(); // 'this' 指向全局 window 对象，因为没有指定引用对象 创建词法环境ES6中 词法环境是一种规范类型，基于 ECMAScript 代码的词法嵌套结构来定义标识符和具体变量和函数的关联。一个词法环境由环境记录器和一个可能的引用外部词法环境的空值组成。 即词法环境是一种持有标识符—变量映射的结构。（这里的标识符指的是变量/函数的名字，而变量是对实际对象[包含函数类型对象]或原始数据的引用）。 两个组件： 环境记录器：存储变量和函数声明的实际位置 外部词法环境的引用：可以访问其父级词法环境（作用域） 词法环境的两种类型： 全局环境（在全局执行上下文中）是没有外部环境引用的词法环境。全局环境的外部环境引用是 null。它拥有内建的 Object/Array/等、在环境记录器内的原型函数（关联全局对象，比如 window 对象）还有任何用户定义的全局变量，并且 this的值指向全局对象。 在函数环境中，函数内部用户定义的变量存储在环境记录器中。并且引用的外部环境可能是全局环境，或者任何包含此内部函数的外部函数。 环境记录器也有两种类型： 对象环境记录器用来定义出现在全局上下文中的变量和函数的关系–全局环境 声明式环境记录器存储变量、函数和参数–函数环境对于函数环境，声明式环境记录器还包含了一个传递给函数的arguments对象（此对象存储索引和参数的映射）和传递给函数的参数的length。 创建变量环境组件变量环境也是一个词法环境，其环境记录器持有变量声明语句在执行上下文中创建的绑定关系。在 ES6 中，词法环境组件和变量环境的一个不同就是前者被用来存储函数声明和变量（let 和 const）绑定，而后者只用来存储 var 变量绑定。 顺便说一下var let const的区别var 变量声明提升,即再var声明之前输出变量不会报错，但会输出undefined。–**已声明并初始化为undefined 没有块级作用域。但是需注意：var操作符定义的变量将成为定义该变量的作用域中的局部变量。即如果是函数中定义的变量，在函数退出后就会被销毁 for循环跳出去之后还会存在 全局下声明的变量为全局对象的属性（）–即可以通过window.a访问 可以重定义，但是会被后面的覆盖。 let 变量声明不会被提升 拥有块级作用域 for循环在每次迭代时都会创建新的绑定 全局下声明的变量为全局变量而不是全局对象的属性–即不可以通过window.a访问 不可以重定义 const 用于定义常量 变量声明不会被提升 不可以重定义 声明的时候一定要初始化–即赋值 不可重新赋值–如果定义的是对象，那么可以修改对象的value值，因为此时常量定义的是一个指向该value的指针 123456789101112131415161718console.log('前',a) // Uncaught ReferenceError: a is not definedconsole.log('前',b) // Uncaught ReferenceError: b is not definedconsole.log('前',c) // undefined 声明前置 但还未初始化let a ;const b = 30,e = &#123;a:'b'&#125;; // 必须初始化var c ,d= 10;console.log(a) // undefinedconsole.log(window.a) // undefined let声明的全局变量不是全局对象的属性console.log(window.d) // 10function multiply(e, f) &#123; var g = 20; return e * f * g;&#125;c = multiply(20, 30);console.log(c)e = &#123;a:'c'&#125; // Assignment to constant variable.e.a = 'new'console.log(e.a) // new JavaScript 执行机制原文链接：这一次，彻底弄懂 JavaScript 执行机制 要记住，JS是单线程语言，js中的多线程是由单线程模拟出来的！ javascript事件循环JS中的任务分为两类： 同步任务 异步任务 主线程内的任务执行完毕为空，会去Event Queue读取对应的函数，进入主线程执行。js引擎存在monitoring process进程，会持续不断的检查主线程执行栈是否为空，一旦为空，就会去Event Queue那里检查是否有等待被调用的函数。123456789let data = [];$.ajax(&#123; url:www.javascript.com, data:data, success:() =&gt; &#123; console.log('发送成功!'); &#125;&#125;)console.log('代码执行结束'); ajax进入Event Table，注册回调函数success 执行console.log(‘代码执行结束’)。 ajax事件完成，回调函数success进入Event Queue。 主线程任务完成后–即console.log(‘代码执行结束’)执行完成后，从Event Queue读取回调函数success并执行。 setTimeout1234setTimeout(() =&gt; &#123; task()&#125;,3000)sleep(10000000) task()进入Event Table并注册,计时开始 执行sleep函数，计时仍在继续 3秒到了，计时事件timeout完成，task()进入Event Queue，但是sleep还没执行完，继续等待 sleep终于执行完了，task()终于从Event Queue进入了主线程执行 setTimeout(fn,0)指定某个任务在主线程最早可得的空闲时间执行，即只要主线程执行栈内的同步任务全部执行完成，栈为空就马上执行题外话： onkeydown - 主要获取和处理当前按下按键 onkeypress - 主要获取和处理长按键。input.value的值在onkeypress之后更新值，即在onkeyup的时候触发DOM元素的更新 onkeyup - 触发onkeyup的DOM元素的值在这里已经更新，可以拿到最新的值，所以这里主要处理相关DOM元素的值。关于setTimeout(fn,0)可读一下这篇文章：JavaScript下的setTimeout(fn,0)意味着什么？ setInterval对于setInterval(fn,ms),每过ms秒，会有fn进入Event Queue。一旦setInterval的回调函数fn执行时间超过了延迟时间ms，那么就完全看不出来有时间间隔了 Promise与process.nextTick(callback)任务有更精细的定义：： macro-task(宏任务)：包括整体代码script，setTimeout，setInterval micro-task(微任务)：Promise，process.nextTick事件流程图：123456789setTimeout(function() &#123; console.log('setTimeout');&#125;)new Promise(function(resolve) &#123; console.log('promise');&#125;).then(function() &#123; console.log('then');&#125;)console.log('console'); 代码作为宏任务进入主线程 代码都是从上到下执行，首先遇到setTimeout,注册其回调函数后发布到宏任务Event Queue 遇到Promise，new promise定义的时候会立即执行console.log(‘promise’)，注册回调函数then()发布到微任务Event Queue 遇到console.log(‘console’)，立即执行 到此，整段代码作为一个宏任务执行结束，按照流程图，查看是否有可执行的微任务？then()函数不可执行是因为new promise立即执行函数里面没有调用回调函数 第一轮事件循环结束，开始新的宏任务console.log(‘setTimeout’)，立即执行 结束 回调函数是作为一个整体进入到Event Queue的12345678910111213141516171819202122232425262728293031323334353637Promise.resolve().then(()=&gt;&#123; console.log('p1111'); Promise.resolve().then(()=&gt;&#123; console.log('p2222'); setTimeout(()=&gt;&#123; console.log('s55555') &#125;,0) Promise.resolve().then(()=&gt;&#123; console.log('p3333') &#125;) &#125;) setTimeout(()=&gt;&#123; console.log('s222'); Promise.resolve().then(()=&gt;&#123; console.log('p5555') &#125;) setTimeout(()=&gt;&#123; console.log('s44444') &#125;,0) &#125;,0) setTimeout(()=&gt;&#123; console.log('s3333'); Promise.resolve().then(()=&gt;&#123; console.log('p6666') &#125;) &#125;,0)&#125;)setTimeout(()=&gt;&#123; console.log('s11'); Promise.resolve().then(()=&gt;&#123; console.log('p4444') &#125;)&#125;,0)console.log('-=-=-=-=-') node环境下的事件监听依赖libuv与前端环境不完全相同，输出顺序可能会有误差 Github地址：每个 JavaScript 工程师都应懂的33个概念 st=>start: 任务进入执行栈 cond=>condition: 同步 op1=>operation: 任务进入主线程 op2=>operation: 已进入主线程的任务全部执行完毕 op3=>operation: 异步事件进入Event Table并注册回调函数 op4=>operation: 异步事件完成,回调函数进入Event Queue e=>end: 读取任务队列中的结果，进入主线程执行 st->cond cond(yes)(left)->op1->op2->e cond(no)(right)->op3->op4->e{"scale":1,"line-width":2,"line-length":50,"text-margin":10,"font-size":12} var code = document.getElementById("flowchart-0-code").value; var options = JSON.parse(decodeURIComponent(document.getElementById("flowchart-0-options").value)); var diagram = flowchart.parse(code); diagram.drawSVG("flowchart-0", options);st=>start: 宏任务 op1=>operation: 执行结束 op2=>operation: 执行所有微任务 cond=>condition: 有可执行的微任务吗？ e=>end: 开始新的宏任务 st->op1->cond cond(yes)(left)->op2->e cond(no)(right)->e{"scale":1,"line-width":2,"line-length":50,"text-margin":10,"font-size":12} var code = document.getElementById("flowchart-1-code").value; var options = JSON.parse(decodeURIComponent(document.getElementById("flowchart-1-options").value)); var diagram = flowchart.parse(code); diagram.drawSVG("flowchart-1", options);]]></content>
      <categories>
        <category>33个JavaScript概念</category>
      </categories>
      <tags>
        <tag>33concepts</tag>
        <tag>JS</tag>
        <tag>v8</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基础总结]]></title>
    <url>%2F2018%2F12%2F31%2FbasicJS%2F</url>
    <content type="text"><![CDATA[Vue基础Vue数据驱动 (主要操作数据) 操作dom js的数据类型 基础类型：Number、String、Boolean、null、undefined Object func Array Symbol(es6) {} []数组的变异 数组操作函数(括号中的能改变数组)：(pop push shift unshift splice reverse sort) indexOf lastIndexOf concat slice forEach filter(过滤) map(映射) some every reduce | includes find (es6) 123456789101112131415161718let arr = [1,2,3,4,5];arr.b='100';for(let i=0;i&lt;arr.length;i++)&#123; // 编程式 console.log(arr[i])&#125;for(let key in arr)&#123; // key会变成string,除了数组，还会遍历出数组的私有属性 console.log(typeof key) // string console.log(key) //&#125;for(let value of Object.keys(obj))&#123; // Object.keys将对象的key作为新的数字 console.log(obj[value])&#125;for(let value of arr)&#123; // 支持return,value of Array,不能遍历对象 console.log(value)&#125;arr.forEach(function(item)&#123; // 声明式，不能return 不关心如何实现 console.log(item);&#125;); filter():不操作原数组 返回结果：过滤后的新数组 回调函数的返回结果：true则表示这一项放到新数组中1234let newArray = [1,2,3,4,5].filter(function(item)&#123; return 2&lt;item&lt;5 // 永远为true 因为先比较2&lt;item 返回值最大为1,1&lt;5永远正确&#125;);console.log(newArray); //[1 2 3 4 5] 正确写法：1234let newArray = [1,2,3,4,5].filter(function(item)&#123; return 2&lt;item &amp;&amp; item&lt;5 &#125;);console.log(newArray); //[3 4] map()：将原有数组映射成新数组 返回新数组 回调函数中返回什么这一项就是什么1234let arr1 = [1,2,3].map(function(item)&#123; return `&lt;li&gt;$&#123;item&#125;&lt;/li&gt;` // ``是ES6中的模板字符串，遇到变量用$&#123;&#125;取值&#125;);console.log(arr1.join('')) // &lt;li&gt;1&lt;/li&gt;&lt;li&gt;2&lt;/li&gt;&lt;li&gt;3&lt;/li&gt; includes():返回boolean值12var arr3 = [1,2,3,4,55]console.log(arr3.includes(5)) // false find():返回找到的那一项 不会改变数组 回调函数中返回true表示找到了，找到后停止循环。找不到返回undefined1234let result = arr3.find(function(item,index)&#123; return item.toString().indexOf(5) &gt; -1&#125;);console.log(result) // 55 some():找true,找到true后停止，返回true。否则返回falseevery():找false,找到false后停止，返回false。否则返回true reduce():收敛函数 4个参数 返回叠加后的结果 原数组不发生变化 回调函数返回的结果：作为下一次循环的第一个参数prev 表示第一项。 next 第二项 数组从索引1开始 index为此时next的索引 item原数组 1234567891011var arr4 = [ &#123;price:30,count:2&#125;, &#123;price:18,count:3&#125;, &#123;price:20,count:3&#125;, &#123;price:15,count:2&#125;, &#123;price:30,count:2&#125;,]let sum = arr4.reduce(function(prev,next)&#123; return prev+next.price*next.count;&#125;,0); // 默认指定第一次的prevconsole.log(sum) 扁平应用：1234var arr5 = [[1,2,3],[4,5,6],[7,8,9]];let flat = arr5.reduce(function(prev,next)&#123; return prev.concat(next)&#125;); 灵魂拷问：Object.create(null) 和 {} 区别是什么：{}相当于Object.create()创建一个空对象，继承Object的属性和方法。而Object.create(null)创建的对象原型是null，null是一个空指针，没有任何属性和方法。所以Object.create(null)就不会继承任何方法和属性。 this指向this的指向有4中模式：默认绑定、隐式绑定、显式绑定(含硬绑定)和new 构造函数 默认绑定在没有任何绑定声明的情况下使用默认绑定1234function foo()&#123; console.log(this); // window&#125;foo() 隐式绑定调用点是否拥有一个环境对象，或（拥有者、容器对象）。通常以obj.xxx()1234567891011"use strict"var name = 'Silvia';var obj = &#123; name:'Alex', sayName:function()&#123; this.name &#125;&#125; obj.sayName() // Alex; var print = obj.sayName; // 绑定丢失print(); // 报错 obj.sayName()存在隐式绑定，此时调用sayName()方法的是obj对象。print()是在全局下调用，由于是在严格模式下，this指向了undefined，没有指向window,所以此时报错。 显示绑定通过bind(硬绑定)/call()/apply()邦定this12345678910var personA = &#123; name: 'Alex', sayName: function () &#123; console.log(this.name) &#125;&#125;var personB = &#123; name: 'Silvia'&#125;personA.sayName.call(personB) // Silvia;// Silvia; 相当于personB借调personA的sayName方法，this指向personB newnew 构造函数的原理是将创建的新对象的proto指向构造函数的prototype，并通过all/apply绑定this为构造函数并执行。通过obj类型返回相应值。12345678910111213function A() &#123; this.name = 'Silvia'; this.sayName = function () &#123; console.log(this.name); // this指向obj return function () &#123; console.log(this) // window &#125; &#125; setTimeout(() =&gt; &#123; this.sayName(); // this指向obj &#125;, 100);&#125;var obj = new A(); // 会打印 Silvia 优先级new &gt; 显式绑定 &gt; 隐式绑定 &gt; 默认模式]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>Vue</tag>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[搭建Hexo个人博客的笔记]]></title>
    <url>%2F2018%2F12%2F29%2FhexoNote%2F</url>
    <content type="text"><![CDATA[这里不做基础讲解，具体内容可查看Hexo官方文档。(发现现在hexo在本地搭建的时候浏览器可以监听到文件的改动了，不知道是不是加了 hexo -w的作用)这里的站点配置文件为根目录下的_config.yml，主题配置文件为themes目录下各个主题的_config.yml 开发环境开始搭建前需确认电脑已安装了一下应用程序： Node git 安装以及初始化Hexo安装12$ npm install -g hexo-cli // 全局安装$ hexo -v // 检测hexo版本 初始化Hexo12$ hexo init blog // blog为项目名称,课自定义$ cd blog // 进入hexo项目 到这里一个初始化的Hexo项目已经搭建好，进入项目可以看到一下几个目录：├── _config.yml├── package.json├── public├── scaffolds├── source| ├── _drafts| └── _posts└── themes scaffolds：模版文件夹。当新建文章时，Hexo会根据scaffold 来建立文件。Hexo的模板是指在新建的markdown文件中默认填充的内容source：资源文件夹是存放用户资源的地方。除 _posts 文件夹之外，开头命名为 _ (下划线)的文件 / 文件夹和隐藏的文件将会被忽略。public：scaffolds文件夹中的Markdown和HTML 文件会被解析并放到public文件夹，而其他文件会被拷贝过去。 配置文件_config.yml网站(site): 解析到index.html文件的meta网址(URL)：http://yoursite.com 即网站的域名。因为我是github托管，所以这里配置为 http://Oldpost.github.iodeploy：配置网站发布的信息 插入图片：_config.yml中1post_asset_folder: true 新建新文章的时候会创建一个.md文件，同时还会创建一个相同名字的文件夹，就可以将图片放到相应的文件夹里面。在文章中引用方式：123&#123;% asset_path slug %&#125;&#123;% asset_img slug [title] %&#125; // eg:&#123;% asset_img cat.jpeg 夏目友人帐 %&#125;&#123;% asset_link slug [title] %&#125; 托管Github登录github并创建一个项目，项目名格式为：账户名.github.io 这样就可以通过http://Oldpost.github.io访问该项目 _config.yml中的相关配置1234url: http://yourGithubName.github.ioroot: /permalink: :year/:month/:day/:title/permalink_defaults: 1234deploy: type: git repo: https://github.com/yourGithubName/yourGithubName.github.io.git branch: master 注意不要把空格去掉，否则会出错 发布网站123$ hexo c // 如果是第一次则不需要$ hexo g$ hexo d // 要保证本地有权限提交代码到github 划重点，掉坑里的域名绑定！！！博客托管Github其实也可以满足需求了，但是绑定到域名感觉上就不一样，你们懂得。这里我是在阿里云买的域名，因为去年买的，关于备案这些有点忘记了，但这不是重点，重点在于域名解析。直接上图 域名解析 这时解析出来的结果就是：blog.silviaxu.com 即自己定义的+购买的域名 Github项目设置域名登录Github–&gt;进入网站仓库(yourName.github.io)–&gt;settings–&gt;下拉找到Custom domain，填写刚刚解析的域名：blog.silviaxu.com (不要乱加其他的东西) –&gt;save保存之后退回到code会发现新增了一个CNAME文件，里面只记录刚刚填写的域名信息blog.silviaxu.com这个文件在每次发布的时候会被清空掉，所以将该文件保存在hexo项目的source目录下，也可以自己创建一个CNAME文件(没有后缀！)，将解析到的域名存进去。 好了，耐心点，静静等待吧 (⊙o⊙)…我的博客差不多要2-3小时 Next 主题及相关配置下载主题1$ git clone https://github.com/theme-next/hexo-theme-next themes/next 将next文件夹复制到hexo项目里的themes目录下，修改站点配置文件_config.yml1theme: next 根据需求配置自己的博客可以根据next官网进行相关配置，这里列举几个本博客的配置 左侧菜单栏 评论 搜索 常用命令启动服务 Run Serve1$ hexo serve 新增一篇文章，eg: note1$ hexo new "note" // 在目录source\_posts下生成一个note.md文件 生成静态文件1$ hexo generate // 该命令可以简写为 $ hexo g 清除缓存文件 (db.json) 和已生成的静态文件 (public)。1$ hexo clean // 该命令可以简写为 $ hexo c 部署网站1$ hexo deploy // 该命令可以简写为 $ hexo d 渲染文件1$ hexo render &lt;file1&gt; [file2] ... 列出网站列表1$ hexo list &lt;type&gt; 新建草稿1$ hexo new draft "new draft" 强行预览草稿，更改配置文件：1render_drafts: true 预览草稿,启动server：1$ hexo server --drafts 显示草稿1$ hexo --draft 发表草稿1$ hexo publish [layout] &lt;filename&gt; 常见错误： The remote end hung up unexpectedly]]></content>
      <categories>
        <category>搭建博客</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
</search>
